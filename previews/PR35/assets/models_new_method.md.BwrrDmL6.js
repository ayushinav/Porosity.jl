import{_ as o,c as i,o as t,an as d}from"./chunks/framework.jd60opwz.js";const m=JSON.parse('{"title":"Contributing","description":"","frontmatter":{},"headers":[],"relativePath":"models/new_method.md","filePath":"models/new_method.md","lastUpdated":null}'),a={name:"models/new_method.md"};function n(c,e,s,l,r,h){return t(),i("div",null,[...e[0]||(e[0]=[d('<h1 id="Contributing" tabindex="-1">Contributing <a class="header-anchor" href="#Contributing" aria-label="Permalink to &quot;Contributing {#Contributing}&quot;">​</a></h1><h2 id="Adding-a-new-rock-physics-equation" tabindex="-1">Adding a new rock physics equation <a class="header-anchor" href="#Adding-a-new-rock-physics-equation" aria-label="Permalink to &quot;Adding a new rock physics equation {#Adding-a-new-rock-physics-equation}&quot;">​</a></h2><p>If you want to add a new rock physics equation, e.g., a conductivity mechanism that got out recently and fits with your research or an anelasticity model you want to add, please open an issue/ pull request.</p><p>Adding a method is the same for all <code>conductivity</code>, <code>elastic</code>, <code>viscous</code> or <code>anelastic</code> methods, and we follow the example of a <code>conductivity</code> method in the steps below:</p><ol><li><p>Add a new <code>mutable struct</code> similar to other definitions in <code>src/conductivity/types.jl</code></p></li><li><p>Define <code>forward</code> dispatch in <code>src/conductivity/forward.jl</code></p></li><li><p>Add the constants to be used in <code>forward</code> dispatch to <code>src/conductivity/cache.jl</code>. It is recommended to look at other <code>params</code> defined in the <code>cache.jl</code> file. Adding empirical constants in <code>params</code> keeps the codebase cleaner and organized.</p></li><li><p>Define dispatch on <code>default_params</code> in <code>src/conductivity/types.jl</code> itself.</p></li><li><p>If required, add other functions in <code>src/conductivity/utils.jl</code></p></li><li><p>Add a new distribution struct in <code>probabilistic/conductivity.jl</code> similar in definition as the <code>struct</code> defined in step 1.</p></li><li><p>Finally export from the <code>src/Porosity.jl</code> file.</p></li></ol><p>It&#39;s always a good idea to add some docstring and test for the methods you add.</p><h2 id="Adding-a-new-phase-mixing-method" tabindex="-1">Adding a new phase mixing method <a class="header-anchor" href="#Adding-a-new-phase-mixing-method" aria-label="Permalink to &quot;Adding a new phase mixing method {#Adding-a-new-phase-mixing-method}&quot;">​</a></h2><p>To add a new phase mixing method, we follow the example of <a href="/Porosity.jl/previews/PR35/api#Porosity.HS1962_plus"><code>HS1962_plus</code></a> :</p><ol><li><p>Define a new <code>mutable struct</code> in <code>src/mixing_phases.jl</code></p></li><li><p>Define the function dispatch <code>mix_model</code> in <code>src/mixing_phases_core.jl</code> which dictates how bulk property can be estimated.</p></li><li><p>Define dispatch on <code>from_nt</code> which basically outputs the object of the same type. This was needed to work things out for <code>MAL</code> and <code>GAL</code>.</p></li><li><p>Finally export from the <code>src/Porosity.jl</code> file.</p></li></ol><p>Please note that the 2-phase mixing models are different from a more general N-phase mixing model. There isn&#39;t much difference when adding a new method except that if it&#39;s a multi-phase mixing model, add that to <code>multi_phase_mix_types</code>, which is a union of all types which work on <a href="/Porosity.jl/previews/PR35/api#Porosity.multi_phase_model"><code>multi_phase_model</code></a> whereas if it&#39;s a two-phase model, add that to <code>two_phase_mix_types</code>.</p>',10)])])}const u=o(a,[["render",n]]);export{m as __pageData,u as default};
