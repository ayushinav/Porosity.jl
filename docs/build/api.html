<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MT.jl</title><meta name="title" content="API · MT.jl"/><meta property="og:title" content="API · MT.jl"/><meta property="twitter:title" content="API · MT.jl"/><meta name="description" content="Documentation for MT.jl."/><meta property="og:description" content="Documentation for MT.jl."/><meta property="twitter:description" content="Documentation for MT.jl."/><meta property="og:url" content="https://ayushinav.github.io/MT/api.html"/><meta property="twitter:url" content="https://ayushinav.github.io/MT/api.html"/><link rel="canonical" href="https://ayushinav.github.io/MT/api.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">MT.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="model.html">model</a></li><li><a class="tocitem" href="forward.html">forward</a></li><li><a class="tocitem" href="deterministic_inverse.html">Deterministic Inverse</a></li><li><a class="tocitem" href="domain_transformation.html">domain transformation</a></li><li><a class="tocitem" href="interface_guide.html">interface guide</a></li><li><span class="tocitem">Probabilistic inverse</span><ul><li><a class="tocitem" href="probabilistic_inverse.html">Interface</a></li><li><a class="tocitem" href="tutorials/fixed_discretization.html">MCMC with fixed discretization</a></li><li><a class="tocitem" href="tutorials/variable_discretization.html">MCMC with variable discretization</a></li><li><a class="tocitem" href="tutorials/rto.html">RTO-TKO</a></li><li><a class="tocitem" href="rock_physics.html">rock physics</a></li></ul></li><li><a class="tocitem" href="vizualization.html">Vizualization</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a></li><li><a class="tocitem" href="working_with_mtpy.html">mtpy tutorial</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ayushinav/MT" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.NonlinearAlg-Tuple{}" href="#MT.NonlinearAlg-Tuple{}"><code>MT.NonlinearAlg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonlinearAlg(; alg = LevenbergMarquardt, μ = 1.0)</code></pre><p>returns <code>nl_cache</code> that specifies which non linear solver to use for the inverse problem</p><p><strong>Keyword Arguments</strong></p><ul><li><code>alg</code>: <code>NonlinearSolve</code>[@ref] algorithm to be used, defaults to LevenbergMarquardt</li><li><code>μ</code> : regularization weight</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.Occam-Tuple{}" href="#MT.Occam-Tuple{}"><code>MT.Occam</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Occam(;μgrid= [0.01, 1e6])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.OptAlg-Tuple{}" href="#MT.OptAlg-Tuple{}"><code>MT.OptAlg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptAlg(; alg = LBFGS, μ = 1.0, kwargs...)</code></pre><p>returns <code>nl_cache</code> that specifies which non linear solver to use for the inverse problem</p><p><strong>Keyword Arguments</strong></p><ul><li><code>alg</code>: <code>NonlinearSolve</code>[@ref] algorithm to be used, defaults to LBFGS</li><li><code>μ</code> : regularization weight</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.construct_mixing_models-NTuple{5, Vector}" href="#MT.construct_mixing_models-NTuple{5, Vector}"><code>MT.construct_mixing_models</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_mixing_models(params, p_names, ϕ, model_list, mixing_type)</code></pre><p>returns a <code>mixing_models</code> type containing all the variables for rock physics modeling</p><p><strong>Arguments</strong></p><ul><li><p><code>params</code> : parameter values for rock physics models</p></li><li><p><code>p_names</code> : list of symbols, each associating with each value in <code>params</code></p></li><li><p><code>ϕ</code> : vol fraction of different phases</p><ul><li>for <code>mixing_type</code> = <code>single_phase</code>, <code>ϕ</code> = <code>[1]</code> (total vol occupied by one phase)</li><li>for <code>mixing_type</code> = <code>HS1962_plus</code> and <code>HS1962_minus</code>, <code>ϕ</code> is a vector of one element that can be varied but should be less than 1. This is the vol melt fraction.</li></ul></li><li><p><code>model_list</code> : list of model types required to build up the rock physics model and mixing them</p></li><li><p><code>mixing_type</code> : determines how to mix model types. Current mixing laws include</p><ul><li><code>single_phase</code> : no mixing, when there&#39;s only a single phase</li><li><code>HS1962_plus</code> : mixing two phases to get the Hashim Strikman upper bound</li><li><code>HS1962_minus</code> : mixing two phases to get the Hashim Strikman lower bound</li><li><code>MAL</code> : mixing the two phases using the Modified Archie&#39;s Law</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.d_sigmoid-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1, T2}" href="#MT.d_sigmoid-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1, T2}"><code>MT.d_sigmoid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>d_sigmoid(m)</code>: gradient for the transformation from optimization domain to model domain. Used for estimating jacobians, but is also useful in analysing sensitivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.forward!-Union{Tuple{T3}, Tuple{T}, Tuple{Tm}, Tuple{Tr}, Tuple{Tr, Tm, T3}, Tuple{Tr, Tm, T3, T}} where {Tr&lt;:MTResponse, Tm&lt;:MTModel, T, T3}" href="#MT.forward!-Union{Tuple{T3}, Tuple{T}, Tuple{Tm}, Tuple{Tr}, Tuple{Tr, Tm, T3}, Tuple{Tr, Tm, T3, T}} where {Tr&lt;:MTResponse, Tm&lt;:MTModel, T, T3}"><code>MT.forward!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>forward!(r::response, m::model, ω::Vector{T}) where T &lt;: Union{Float32, Float64}</code>:</p><p>updates response <code>r</code> type for the given model <code>m</code> at the frequencies  <code>ω</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.forward-Union{Tuple{T3}, Tuple{T}, Tuple{Tm}, Tuple{Tm, T3}, Tuple{Tm, T3, T}} where {Tm&lt;:MTModel, T, T3}" href="#MT.forward-Union{Tuple{T3}, Tuple{T}, Tuple{Tm}, Tuple{Tm, T3}, Tuple{Tm, T3, T}} where {Tm&lt;:MTModel, T, T3}"><code>MT.forward</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>forward(m::model, ω::Vector{T}) where T &lt;: Union{Float32, Float64}</code>:</p><p>returns a  <code>response</code> for the given model <code>m</code> at the frequencies  <code>ω</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.gaussian_kernel" href="#MT.gaussian_kernel"><code>MT.gaussian_kernel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian_kernel(u, σ² = 2)</code></pre><p>return gaussian kernel centered at 0, at points given by <code>u</code> with std deviation of <code>σ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_appres-Tuple{Any, Any}" href="#MT.get_appres-Tuple{Any, Any}"><code>MT.get_appres</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>get_appres(Z, ω)</code>: returns the ρₐ for impedance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_kde-Tuple{Any, Any}" href="#MT.get_kde-Tuple{Any, Any}"><code>MT.get_kde</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_kde(data, xgrid; Κ= gaussian_kernel)</code></pre><p>returns distribution of <code>data</code> using kernel density estimation</p><p><strong>Arguments</strong></p><ul><li><code>data</code> : 1D vector to evaluate distribution for</li><li><code>xgrid</code> : 1D vector to evaluate distribution on</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Κ</code> : kernel used to evaluate density, defaults to <code>gaussian_kernel</code>[@ref]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_kde_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C&lt;:MCMCChains.Chains, mdist&lt;:(MTModelDistribution{&lt;:Distributions.Distribution, &lt;:AbstractArray})}" href="#MT.get_kde_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C&lt;:MCMCChains.Chains, mdist&lt;:(MTModelDistribution{&lt;:Distributions.Distribution, &lt;:AbstractArray})}"><code>MT.get_kde_image!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_kde_image!(fig,
    chain::C,
    mDist::mdist;
    hm_kwargs=(;),
    cb_kwargs=(;),
    K=gaussian_kernel,
    half_space_depth=nothing,
    kde_transformation_fn = identity,
    return_kde_mat=false,
    trans_utils=(m=lin_tf, h=lin_tf),
    grid=(m=collect(-1:0.1:5), z=cumsum(mDist.h))) where {
    C &lt;: Chains, mdist &lt;: MTModelDistribution{&lt;:Distribution, &lt;:AbstractArray}}</code></pre><p>plots on <code>fig</code>, a heatmap of probability distributions sampled by a <code>chain</code> using kernel density estimation</p><p><strong>Arguments</strong></p><ul><li><code>fig</code> : Figure on which the heatmap is plotted</li><li><code>chain</code> : samples in the form <code>Turing.Chains</code> from an MCMC sampling</li><li><code>mDist</code> : <em>apriori</em> model distribution used for MCMC sampling</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>hm_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for customizing heatmap</li><li><code>cb_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for customizing colorbar</li><li><code>K</code> : kernel used to perform kernel density estimation</li><li><code>half_space_depth</code> : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to <code>1.25 × last</code></li><li><code>kde_transformation_fn</code> : a function that transforms the image domain, eg., use <code>log10</code> to plot log pdf; defaults to <code>identity</code> which implies no bounds_transformation</li><li><code>return_kde_mat</code> : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to <code>false</code></li><li><code>trans_utils</code> : <code>NamedTuple</code> containing functions to transform the samples; defaults to no <code>lin_tf</code> for all parameters</li><li><code>grid</code> : <code>NamedTuple</code> containing grid to evaluate the kernel density on. <code>m</code> refers to the points to evaluate kde of model parameters, <code>z</code> refers to the depth points at which the model samples are inferred, not used if <code>h</code> is not sampled.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Also check relevant tutorial page!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_kde_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C&lt;:MCMCChains.Chains, mdist&lt;:(MTModelDistribution{&lt;:Distributions.Distribution, &lt;:Distributions.Distribution})}" href="#MT.get_kde_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C&lt;:MCMCChains.Chains, mdist&lt;:(MTModelDistribution{&lt;:Distributions.Distribution, &lt;:Distributions.Distribution})}"><code>MT.get_kde_image!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_kde_image!(fig,
    chain,
    mDist;
    hm_kwargs=(;),
    cb_kwargs=(;),
    K=gaussian_kernel,
    half_space_depth=nothing,
    kde_transformation_fn = identity,
    return_kde_mat=false,
    trans_utils=(m=lin_tf, h=lin_tf),
    grid=(m=collect(-1:0.1:5), z=cumsum(mDist.h))) where {
    C &lt;: Chains, mdist &lt;: MTModelDistribution}</code></pre><p>plots on <code>fig</code>, a heatmap of probability distributions sampled by a <code>chain</code> using kernel density estimation</p><p><strong>Arguments</strong></p><ul><li><code>fig</code> : Figure on which the heatmap is plotted</li><li><code>chain</code> : samples in the form <code>Turing.Chains</code> from an MCMC sampling</li><li><code>mDist</code> : <em>apriori</em> model distribution used for MCMC sampling</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>hm_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for customizing heatmap</li><li><code>cb_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for customizing colorbar</li><li><code>K</code> : kernel used to perform kernel density estimation</li><li><code>half_space_depth</code> : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to <code>1.25 × last</code></li><li><code>kde_transformation_fn</code> : a function that transforms the image domain, eg., use <code>log10</code> to plot log pdf; defaults to <code>identity</code> which implies no bounds_transformation</li><li><code>return_kde_mat</code> : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to <code>false</code></li><li><code>trans_utils</code> : <code>NamedTuple</code> containing functions to transform the samples; defaults to no <code>lin_tf</code> for all parameters</li><li><code>grid</code> : <code>NamedTuple</code> containing grid to evaluate the kernel density on. <code>m</code> refers to the points to evaluate kde of model parameters, <code>z</code> refers to the depth points at which the model samples are inferred, not used if <code>h</code> is not sampled.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Also check relevant tutorial page!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_kde_image-Tuple" href="#MT.get_kde_image-Tuple"><code>MT.get_kde_image</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_kde_image!(fig,
    chain,
    mDist;
    hm_kwargs=(;),
    cb_kwargs=(;),
    K=gaussian_kernel,
    half_space_depth=nothing,
    kde_transformation_fn = identity,
    return_kde_mat=false,
    trans_utils=(m=lin_tf, h=lin_tf),
    grid=(m=collect(-1:0.1:5), z=cumsum(mDist.h)))</code></pre><p>returns <code>fig</code>, a heatmap of probability distributions sampled by a <code>chain</code> using kernel density estimation</p><p><strong>Arguments</strong></p><ul><li><code>fig</code> : Figure on which the heatmap is plotted</li><li><code>chain</code> : samples in the form <code>Turing.Chains</code> from an MCMC sampling</li><li><code>mDist</code> : <em>apriori</em> model distribution used for MCMC sampling</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>hm_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for customizing heatmap</li><li><code>cb_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for customizing colorbar</li><li><code>K</code> : kernel used to perform kernel density estimation</li><li><code>half_space_depth</code> : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to <code>1.25 × last</code></li><li><code>kde_transformation_fn</code> : a function that transforms the image domain, eg., use <code>log10</code> to plot log pdf; defaults to <code>identity</code> which implies no bounds_transformation</li><li><code>return_kde_mat</code> : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to <code>false</code></li><li><code>trans_utils</code> : <code>NamedTuple</code> containing functions to transform the samples; defaults to no <code>lin_tf</code> for all parameters</li><li><code>grid</code> : <code>NamedTuple</code> containing grid to evaluate the kernel density on. <code>m</code> refers to the points to evaluate kde of model parameters, <code>z</code> refers to the depth points at which the model samples are inferred, not used if <code>h</code> is not sampled.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Also check relevant tutorial page!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_mean_std_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, Any, Any}} where {C&lt;:MCMCChains.Chains, mdist&lt;:(MTModelDistribution{&lt;:Distributions.Distribution, &lt;:AbstractArray})}" href="#MT.get_mean_std_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, Any, Any}} where {C&lt;:MCMCChains.Chains, mdist&lt;:(MTModelDistribution{&lt;:Distributions.Distribution, &lt;:AbstractArray})}"><code>MT.get_mean_std_image!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_mean_std_image!(ax,
    chain,
    mDist::mdist;
    confidence_interval=0.95,
    half_space_depth=nothing,
    plot_kwargs=nothing,
    trans_utils=(m=lin_tf, h=lin_tf))</code></pre><p>plots on <code>ax</code>, a bounds plot (using mean and std deviation) of probability distributions sampled by a <code>chain</code> using kernel density estimation</p><p><strong>Arguments</strong></p><ul><li><code>fig</code> : Axis on which the probability bounds are plotted</li><li><code>chain</code> : samples in the form <code>Turing.Chains</code> from an MCMC sampling</li><li><code>mDist</code> : <em>apriori</em> model distribution used for MCMC sampling</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_interval</code> : a <code>confidence_interval</code> of <code>0.9</code> implies 90% of values are within the bounds</li><li><code>half_space_depth</code> : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to <code>1.25 × last</code></li><li><code>plot_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for plots</li><li><code>return_kde_mat</code> : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to <code>false</code></li><li><code>trans_utils</code> : <code>NamedTuple</code> containing functions to transform the samples; defaults to no <code>lin_tf</code> for all parameters</li><li><code>z_points</code> : depth points at which bounds are plotted, not used if <code>h</code> is not sampled; defaults to depths corresponding to <code>mean(h)</code></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Also check relevant tutorial page!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_mean_std_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C&lt;:MCMCChains.Chains, mdist&lt;:(MTModelDistribution{&lt;:Distributions.Distribution, &lt;:Distributions.Distribution})}" href="#MT.get_mean_std_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C&lt;:MCMCChains.Chains, mdist&lt;:(MTModelDistribution{&lt;:Distributions.Distribution, &lt;:Distributions.Distribution})}"><code>MT.get_mean_std_image!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_mean_std_image!(ax,
    chain,
    mDist;
    confidence_interval=0.95,
    half_space_depth=nothing,
    plot_kwargs=nothing,
    trans_utils=(m=lin_tf, h=lin_tf))</code></pre><p>plots on <code>ax</code>, a bounds plot (using mean and std deviation) of probability distributions sampled by a <code>chain</code> using kernel density estimation</p><p><strong>Arguments</strong></p><ul><li><code>fig</code> : Axis on which the probability bounds are plotted</li><li><code>chain</code> : samples in the form <code>Turing.Chains</code> from an MCMC sampling</li><li><code>mDist</code> : <em>apriori</em> model distribution used for MCMC sampling</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_interval</code> : a <code>confidence_interval</code> of <code>0.9</code> implies 90% of values are within the bounds</li><li><code>half_space_depth</code> : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to <code>1.25 × last</code></li><li><code>plot_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for plots</li><li><code>return_kde_mat</code> : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to <code>false</code></li><li><code>trans_utils</code> : <code>NamedTuple</code> containing functions to transform the samples; defaults to no <code>lin_tf</code> for all parameters</li><li><code>z_points</code> : depth points at which bounds are plotted, not used if <code>h</code> is not sampled; defaults to depths corresponding to <code>mean(h)</code></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Also check relevant tutorial page!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_mean_std_image-Tuple" href="#MT.get_mean_std_image-Tuple"><code>MT.get_mean_std_image</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_mean_std_image!(chain,
    mDist;
    confidence_interval=0.95,
    half_space_depth=nothing,
    plot_kwargs=nothing,
    trans_utils=(m=lin_tf, h=lin_tf))</code></pre><p>return <code>fig</code>, a figure with a bounds plot (using mean and std deviation) of probability distributions sampled by a <code>chain</code> using kernel density estimation</p><p><strong>Arguments</strong></p><ul><li><code>fig</code> : Axis on which the probability bounds are plotted</li><li><code>chain</code> : samples in the form <code>Turing.Chains</code> from an MCMC sampling</li><li><code>mDist</code> : <em>apriori</em> model distribution used for MCMC sampling</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_interval</code> : a <code>confidence_interval</code> of <code>0.9</code> implies 90% of values are within the bounds</li><li><code>half_space_depth</code> : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to <code>1.25 × last</code></li><li><code>plot_kwargs</code> : <code>NamedTuple</code> containing keyword arguments for plots</li><li><code>return_kde_mat</code> : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to <code>false</code></li><li><code>trans_utils</code> : <code>NamedTuple</code> containing functions to transform the samples; defaults to no <code>lin_tf</code> for all parameters</li><li><code>z_points</code> : depth points at which bounds are plotted, not used if <code>h</code> is not sampled; defaults to depths corresponding to <code>mean(h)</code></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Also check relevant tutorial page!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_model_list-Union{Tuple{chain}, Tuple{mdist}, Tuple{chain, mdist}} where {mdist&lt;:AbstractModelDistribution, chain&lt;:MCMCChains.Chains}" href="#MT.get_model_list-Union{Tuple{chain}, Tuple{mdist}, Tuple{chain, mdist}} where {mdist&lt;:AbstractModelDistribution, chain&lt;:MCMCChains.Chains}"><code>MT.get_model_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_model_list(chains::chain, mDist::mdist; 
    trans_utils = (m = pow_tf, h = lin_tf,)) where {mdist &lt;: AbstractModelDistribution, chain &lt;: Chains}</code></pre><p>returns a list of models from the <code>Chains</code> variable obtained from <a href="api.html#MT.stochastic_inverse-Union{Tuple{resp2}, Tuple{resp1}, Tuple{resp1, resp2, Any, mcmc_cache}} where {resp1&lt;:AbstractResponse, resp2&lt;:AbstractResponse}"><code>stochastic_inverse</code></a></p><p><strong>Arguments</strong></p><ul><li><code>chains</code> : <code>Chains</code> object obtained from the <code>Turing</code> model</li><li><code>mDist</code> : <em>a priori</em> distribution defined before performing stochastic inversion</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_phase-Tuple{Any}" href="#MT.get_phase-Tuple{Any}"><code>MT.get_phase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>get_phase(Z)</code>: returns the phase for impedance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.get_ρ_at_z-Tuple{Any, Any}" href="#MT.get_ρ_at_z-Tuple{Any, Any}"><code>MT.get_ρ_at_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ρ_at_z(pred, zs)</code></pre><p>returns the values of the model splatted as a vector in <code>pred</code> at points defined by <code>zs</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.inverse!-Union{Tuple{resp_utils_T}, Tuple{trans_utils_T}, Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, occam_cache}} where {model1&lt;:AbstractGeophyModel, response&lt;:AbstractGeophyResponse, trans_utils_T, resp_utils_T}" href="#MT.inverse!-Union{Tuple{resp_utils_T}, Tuple{trans_utils_T}, Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, occam_cache}} where {model1&lt;:AbstractGeophyModel, response&lt;:AbstractGeophyResponse, trans_utils_T, resp_utils_T}"><code>MT.inverse!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function inverse!(mₖ::model,
        robs::response,
        vars::Vector{Float64},
        alg_cache::occam_cache;
        W= nothing,
        L= nothing,
        max_iters= 30, χ2=1.,
        response_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(robs))],
        model_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(m₀))], # this will not be used but for the sake of generality for all inverse algs
        model_trans_utils::transform_utils= sigmoid_tf,
        verbose= true
    ):</code></pre><p>updates <code>mₖ</code> using occam iteration to fit <code>robs</code> within a misfit of <code>χ2</code>, by default set to 1.0</p><p><strong>Variables:</strong></p><ul><li><code>mₖ</code>: Initial model guess, will be updated during the inverse process</li><li><code>robs</code>: response to invert for</li><li><code>vars</code>: variables required for forward modeling, eg., <code>ω</code> for MT</li><li><code>alg_cache</code>: deterimines the algorithm to be performed for inversion</li><li><code>W</code>: Weight matrix, defaults to identity matrix <code>I</code></li><li><code>L</code>: Regularization matrix, defaults to derivative matrix, given by <code>∂</code>(@ref)</li><li><code>max_iters= 30</code>: maximum number of iterations</li><li><code>χ2=1.</code>: target misfit</li><li>`response_fields: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)</li><li><code>model_trans_utils:transform_utils= pow_sigmoid_tf</code>: conversion to and from computational domain,</li><li><code>response_trans_utils</code>: for scaling the response parameters,</li><li><code>mᵣ</code>: model in physical domain to be regularized against</li><li><code>reg_term</code>: (For internals) When model in physical domain does not exist, <code>reg_term</code> helps, eg. case of RTO-TKO</li><li><code>verbose</code>: whether to print updates after each iteration, defaults to true</li></ul><p><strong>Returns:</strong></p><p>return message in the form of <code>return_code</code> and updates <code>mₖ</code> in-place.</p><p><strong>Example:</strong></p><p><code>inverse!(m_occam, r_obs, Occam([1e-2, 1e6]))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.inverse!-Union{Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, nl_cache}} where {model1&lt;:AbstractGeophyModel, response&lt;:AbstractGeophyResponse}" href="#MT.inverse!-Union{Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, nl_cache}} where {model1&lt;:AbstractGeophyModel, response&lt;:AbstractGeophyResponse}"><code>MT.inverse!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function inverse!(mₖ::model1,
        robs::response,
        vars::Vector{Float64},
        alg_cache::nl_cache;
        W=nothing,
        L=nothing,
        max_iters=30,
        χ2=1.0,
        response_fields::Vector{Symbol}=[k for k in fieldnames(typeof(robs))],
        # model_fields::Vector{Symbol}=[k for k in fieldnames(typeof(mₖ))], # this will not be used but for the sake of generality for all inverse algs
        model_trans_utils::transform_utils=pow_sigmoid_tf,
        response_trans_utils::transform_utils=log_tf,
        verbose::Bool=true,
        mᵣ=nothing) where {
        model1 &lt;: AbstractGeophyModel, response &lt;: AbstractGeophyResponse}</code></pre><p>updates <code>mₖ</code> using occam iteration to fit <code>robs</code> within a misfit of <code>χ2</code>, by default set to 1.0.</p><p><strong>Variables:</strong></p><ul><li><code>mₖ</code>: Initial model guess, will be updated during the inverse process</li><li><code>robs</code>: response to invert for</li><li><code>vars</code>: variables required for forward modeling, eg., <code>ω</code> for MT</li><li><code>alg_cache::occam_cache</code>: deterimines the algorithm to be performed for inversion</li><li><code>W</code>: Weight matrix, will be <code>I</code> if nothing is provided</li><li><code>L</code>: Regularization matrix, defaults to derivative matrix, given by <code>∂</code>[@ref]</li><li><code>max_iters</code>: maximum number of iterations, defaults to 30</li><li><code>χ2</code>: threshold misfit, defaults to 1.0</li><li><code>response_fields</code>: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)</li><li><code>model_fields</code>: will generally be fixed, see docs for details</li><li><code>model_trans_utils</code>: conversion to and from computational domain,</li><li><code>response_trans_utils</code>: for scaling the response parameters,</li><li><code>verbose</code>: whether to print updates after each iteration, defaults to true</li><li><code>mᵣ</code>: model in physical domain to be regularized against</li></ul><p><strong>Returns:</strong></p><p>return message in the form of <code>return_code</code> and updates <code>mₖ</code> in-place.</p><p><strong>Example:</strong></p><p><code>inverse!(m_occam, r_obs, ω, NonlinearAlg(; alg = LevenbergMarquardt, μ = 1.0))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.inverse!-Union{Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, opt_cache}} where {model1&lt;:AbstractGeophyModel, response&lt;:AbstractGeophyResponse}" href="#MT.inverse!-Union{Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, opt_cache}} where {model1&lt;:AbstractGeophyModel, response&lt;:AbstractGeophyResponse}"><code>MT.inverse!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function inverse!(mₖ::model1,
        robs::response,
        vars::Vector{Float64},
        alg_cache::opt_cache;
        W=nothing,
        L=nothing,
        max_iters=30,
        χ2=1.0,
        response_fields::Vector{Symbol}=[k for k in fieldnames(typeof(robs))],
        # model_fields::Vector{Symbol}=[k for k in fieldnames(typeof(mₖ))], # this will not be used but for the sake of generality for all inverse algs
        model_trans_utils::transform_utils=pow_sigmoid_tf,
        response_trans_utils::transform_utils=log_tf,
        verbose::Bool=true,
        mᵣ=nothing) where {
        model1 &lt;: AbstractGeophyModel, response &lt;: AbstractGeophyResponse}</code></pre><p>updates <code>mₖ</code> using occam iteration to fit <code>robs</code> within a misfit of <code>χ2</code>, by default set to 1.0.</p><p><strong>Variables:</strong></p><ul><li><code>mₖ</code>: Initial model guess, will be updated during the inverse process</li><li><code>robs</code>: response to invert for</li><li><code>vars</code>: variables required for forward modeling, eg., <code>ω</code> for MT</li><li><code>alg_cache::occam_cache</code>: deterimines the algorithm to be performed for inversion</li><li><code>W</code>: Weight matrix, will be <code>I</code> if nothing is provided</li><li><code>L</code>: Regularization matrix, defaults to derivative matrix, given by <code>∂</code>[@ref]</li><li><code>max_iters</code>: maximum number of iterations, defaults to 30</li><li><code>χ2</code>: threshold misfit, defaults to 1.0</li><li><code>response_fields</code>: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)</li><li><code>model_fields</code>: will generally be fixed, see docs for details</li><li><code>model_trans_utils</code>: conversion to and from computational domain,</li><li><code>response_trans_utils</code>: for scaling the response parameters,</li><li><code>verbose</code>: whether to print updates after each iteration, defaults to true</li><li><code>mᵣ</code>: model in physical domain to be regularized against</li></ul><p><strong>Returns:</strong></p><p>return message in the form of <code>return_code</code> and updates <code>mₖ</code> in-place.</p><p><strong>Example:</strong></p><p><code>inverse!(m_occam, r_obs, ω, NonlinearAlg(; alg = LBFGS, μ = 1.0))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.inverse_sigmoid-Union{Tuple{T1}, Tuple{T}, Tuple{T1, Vector{T}}} where {T&lt;:Union{Float32, Float64}, T1}" href="#MT.inverse_sigmoid-Union{Tuple{T1}, Tuple{T}, Tuple{T1, Vector{T}}} where {T&lt;:Union{Float32, Float64}, T1}"><code>MT.inverse_sigmoid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>inverse_sigmoid()</code>: get back to the optimization domain from model domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.linsolve!-NTuple{4, Any}" href="#MT.linsolve!-NTuple{4, Any}"><code>MT.linsolve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>linsolve!</code>: Performs <code>inv(B)*y</code> using <code>LinearSolve.jl</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.mcmc_turing-Union{Tuple{rdist}, Tuple{mdist}, Tuple{response}, Tuple{model}, Tuple{model, Any, Any, NamedTuple, response, mdist, rdist}} where {model&lt;:AbstractModel, response&lt;:AbstractResponse, mdist&lt;:AbstractModelDistribution, rdist&lt;:AbstractResponseDistribution}" href="#MT.mcmc_turing-Union{Tuple{rdist}, Tuple{mdist}, Tuple{response}, Tuple{model}, Tuple{model, Any, Any, NamedTuple, response, mdist, rdist}} where {model&lt;:AbstractModel, response&lt;:AbstractResponse, mdist&lt;:AbstractModelDistribution, rdist&lt;:AbstractResponseDistribution}"><code>MT.mcmc_turing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@model function mcmc_turing(
    m_sample::model,
    vars,
    r_obs::NamedTuple,
    err_resp::MTResponse,
    mDist::mdist,
    rDist::rdist;
    response_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(rDist))],
    model_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(mDist))],
    trans_utils::NamedTuple = (m = log_tf, h = lin_tf)
    ) where {model &lt;: AbstractModel, mdist &lt;: AbstractModelDistribution, rdist &lt;: AbstractResponseDistribution}</code></pre><p>makes a <code>Turing.jl</code> model to perform MCMC sampling</p><p><strong>Variables:</strong></p><ul><li><code>vars</code>: variables that need to be passed into the <code>forward</code> function along with <code>model</code> to generate a <code>response</code></li><li><code>r_obs</code>: named tuple containing the observed data, with the same keys as the fields in the corresponding <code>response</code></li><li><code>err_resp</code>: <code>response</code> variable that contains the errors</li><li><code>mDist</code>: any subtype of <a href="api.html#MT.AbstractModelDistribution"><code>AbstractModelDistribution</code></a> contains the apriori information</li><li><code>rDist</code>: any subtype of <a href="api.html#MT.AbstractResponseDistribution"><code>AbstractResponseDistribution</code></a> contains the likelihood information</li></ul><p><strong>Keyword/optional arguments</strong></p><ul><li><code>response_fields</code>:  which fields in <code>response</code> to invert for</li><li><code>model_fields</code>: fields in <code>model</code> to draw inference on</li><li><code>trans_utils</code>: to transform the model field variables to and from computational (inference) domain</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.normal_dist-Tuple{AbstractVector, AbstractVector}" href="#MT.normal_dist-Tuple{AbstractVector, AbstractVector}"><code>MT.normal_dist</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>normal_dist(resp::AbstractVector, err_resp::AbstractVector)</code>: returns a multivariate normal distribution centered around <code>resp</code> with std dev <code>err_resp</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.occam_step!-Union{Tuple{response}, Tuple{model2}, Tuple{model1}, Tuple{model1, response, Union{AbstractVector{Float32}, AbstractVector{Float64}}, Union{Float32, Float64}, Vector{Float64}, linear_utils, inverse_utils, transform_utils, NamedTuple, LinearSolve.LinearCache}} where {model1&lt;:AbstractGeophyModel, model2&lt;:Union{Nothing, AbstractGeophyModel}, response&lt;:AbstractGeophyResponse}" href="#MT.occam_step!-Union{Tuple{response}, Tuple{model2}, Tuple{model1}, Tuple{model1, response, Union{AbstractVector{Float32}, AbstractVector{Float64}}, Union{Float32, Float64}, Vector{Float64}, linear_utils, inverse_utils, transform_utils, NamedTuple, LinearSolve.LinearCache}} where {model1&lt;:AbstractGeophyModel, model2&lt;:Union{Nothing, AbstractGeophyModel}, response&lt;:AbstractGeophyResponse}"><code>MT.occam_step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function occam_step!(mₖ₊₁::model,
    respₖ₊₁::response,
    vars::Union{AbstractVector{Float32}, AbstractVector{Float64}},
    χ2::Union{Float64, Float32},
    μgrid::Vector{Float64},
    lin_utils::linear_utils,
    inv_utils::inverse_utils,
    model_trans_utils::transform_utils,
    response_trans_utils::NamedTuple,
    linsolve_prob::LinearSolve.LinearCache;
    model_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(mₖ₊₁))],
    response_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(respₖ₊₁))],
    verbose= false
    ):</code></pre><p>performs a single step of occam inversion, using golden line search.</p><p><strong>Variables:</strong></p><ul><li><code>mₖ</code>: Initial model guess, will be updated during the inverse process</li><li><code>robs</code>: response to invert for</li><li><code>vars</code>: variables required for forward modeling, eg., <code>ω</code> for MT</li><li><code>alg_cache</code>: deterimines the algorithm to be performed for inversion</li><li><code>W</code>: Weight matrix, defaults to identity matrix <code>I</code></li><li><code>L</code>: Regularization matrix, defaults to discretized derivative matrix given by ∂(@ref)</li><li><code>max_iters</code>: maximum number of iterations, defaults to 30</li><li><code>χ2</code>: target misfit, defaults to 1.0</li><li>`response_fields: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)</li><li><code>model_trans_utils</code>: conversion to and from computational domain,</li><li><code>response_trans_utils</code>: NamedTuple containing <code>transform_utils</code> for scaling different response parameters,</li><li><code>mᵣ</code>: model in physical domain to be regularized against</li><li><code>reg_term</code>: (For internals) When model in physical domain does not exist, <code>reg_term</code> helps, eg. case of RTO-TKO</li><li><code>verbose</code>: whether to print updates after each iteration, defaults to true</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.stochastic_inverse-Union{Tuple{resp2}, Tuple{resp1}, Tuple{resp1, resp2, Any, mcmc_cache}} where {resp1&lt;:AbstractResponse, resp2&lt;:AbstractResponse}" href="#MT.stochastic_inverse-Union{Tuple{resp2}, Tuple{resp1}, Tuple{resp1, resp2, Any, mcmc_cache}} where {resp1&lt;:AbstractResponse, resp2&lt;:AbstractResponse}"><code>MT.stochastic_inverse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stochastic_inverse(
    r_obs::response,
    err_resp::response,
    vars,
    alg_cache::mcmc_cache;
    model_trans_utils::NamedTuple = (m = lin_tf, h = lin_tf)
    )</code></pre><p>function to perform sampling</p><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">`AbstractMCMC.jl Chain` containing the vectors used for performing samping. Note that all the variables will be named `var_inf`, for variable inferred. 
The vector in each sample will be all the fields of the model being inferred on concatenated together.</code></pre><p><strong>Variables</strong></p><ul><li><code>r_obs</code>: <code>response</code> that needs to inverted for</li><li><code>err_resp</code>: <code>response</code> variable containing the errors associated with observed response</li><li><code>vars</code>: variables that need to be passed into the <code>forward</code> function along with <code>model</code> to generate a <code>response</code></li><li><code>alg_cache</code>: to tell the compiler what type of stochastic inversion method is to be used</li><li><code>model_trans_utils</code>: A named tuple containing <code>transform_utils</code> for the fields of model that need to be scaled/modified. If not provided for any <code>model</code> field, the field won&#39;t be modified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.stochastic_inverse-Union{Tuple{resp2}, Tuple{resp1}, Tuple{resp1, resp2, Any, rto_cache}} where {resp1&lt;:AbstractGeophyResponse, resp2&lt;:AbstractGeophyResponse}" href="#MT.stochastic_inverse-Union{Tuple{resp2}, Tuple{resp1}, Tuple{resp1, resp2, Any, rto_cache}} where {resp1&lt;:AbstractGeophyResponse, resp2&lt;:AbstractGeophyResponse}"><code>MT.stochastic_inverse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stochastic_inverse(r_obs::resp1,
        err_resp::resp2,
        vars,
        alg_cache::rto_cache;
        model_trans_utils::NamedTuple=(m=sigmoid_tf, h=lin_tf),
        response_trans_utils::NamedTuple=(ρₐ=lin_tf, ϕ=lin_tf)) where {
        resp1 &lt;: AbstractGeophyResponse, resp2 &lt;: AbstractGeophyResponse}</code></pre><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">`AbstractMCMC.jl Chain` containing the vectors used for performing samping. Note that all the variables will be named `var_inf`, for variable inferred. 
The vector in each sample will be all the fields of the model being inferred on concatenated together.</code></pre><p><strong>Arguments</strong></p><ul><li><code>r_obs</code>: <code>response</code> that needs to inverted for</li><li><code>err_resp</code>: <code>response</code> variable containing the errors associated with observed response</li><li><code>vars</code>: variables that need to be passed into the <code>forward</code> function along with <code>model</code> to generate a <code>response</code></li><li><code>alg_cache</code>: to tell the compiler what type of stochastic inversion method is to be used</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>model_trans_utils</code>: A named tuple containing <code>transform_utils</code> for the fields of model that need to be scaled/modified. If not provided for any <code>model</code> field, the field won&#39;t be modified</li><li><code>response_trans_utils</code>: for scaling the response parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.uniform_dist-Tuple{AbstractVector, AbstractVector}" href="#MT.uniform_dist-Tuple{AbstractVector, AbstractVector}"><code>MT.uniform_dist</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>uniform_dist(resp::AbstractVector, err_resp::AbstractVector)</code>: returns a uniform normal distribution ∈ [<code>resp</code>-<code>err_resp</code>/2, <code>resp</code>+<code>err_resp</code>/2]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.χ²-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1, T2}" href="#MT.χ²-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1, T2}"><code>MT.χ²</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>χ²(dcal::T, dobs::T; W)</code>: returns a chi-squared error between the observed and the calculated data. <code>W</code> can optionally be passed to weigh points differently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.∂-Tuple{Any}" href="#MT.∂-Tuple{Any}"><code>MT.∂</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>∂(n)</code>: returns a <code>n</code>x<code>n</code> matrix for a 1D finite difference stencil using 2 points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractGeophyModel" href="#MT.AbstractGeophyModel"><code>MT.AbstractGeophyModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all geophysical models in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractGeophyModelDistribution" href="#MT.AbstractGeophyModelDistribution"><code>MT.AbstractGeophyModelDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all geophysical <code>model</code> distributions in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractGeophyResponse" href="#MT.AbstractGeophyResponse"><code>MT.AbstractGeophyResponse</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all geophysical responses in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractGeophyResponseDistribution" href="#MT.AbstractGeophyResponseDistribution"><code>MT.AbstractGeophyResponseDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all geophysical <code>response</code> distributions in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractModel" href="#MT.AbstractModel"><code>MT.AbstractModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all <code>model</code>s in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractModelDistribution" href="#MT.AbstractModelDistribution"><code>MT.AbstractModelDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all <code>model</code> distributions in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractResponse" href="#MT.AbstractResponse"><code>MT.AbstractResponse</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all <code>response</code>s in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractResponseDistribution" href="#MT.AbstractResponseDistribution"><code>MT.AbstractResponseDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all <code>response</code> distributions in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractRockphyModel" href="#MT.AbstractRockphyModel"><code>MT.AbstractRockphyModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all rock models in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractRockphyModelDistribution" href="#MT.AbstractRockphyModelDistribution"><code>MT.AbstractRockphyModelDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all rock physics <code>model</code> distributions in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractRockphyResponse" href="#MT.AbstractRockphyResponse"><code>MT.AbstractRockphyResponse</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all rock physics responses in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.AbstractRockphyResponseDistribution" href="#MT.AbstractRockphyResponseDistribution"><code>MT.AbstractRockphyResponseDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type that is the supertype of all rock physics <code>response</code> distributions in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.Gaillard2008" href="#MT.Gaillard2008"><code>MT.Gaillard2008</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gaillard2008(T)</code></pre><p>Electrical conductivity model for melt dependent on Temperature. For further reading look at the references below.</p><p><strong>Usage</strong></p><p>julia&gt; model = Gaillard2008(1000 + 273.)</p><p>julia&gt; log_cond = forward(model, [])</p><p><strong>Arguments</strong></p><ul><li><code>T</code> : Temperature of melt (should be greater than 1146.8 K)</li></ul><p><strong>References</strong></p><p>Gaillard, Fabrice &amp; Malki, Mohammed &amp; Iacono-Marziano, Giada &amp; Pichavant, Michel &amp; Scaillet, Bruno. (2008), &quot;Carbonatite Melts and Electrical Conductivity in the Asthenosphere&quot;, Science (New York, N.Y.). 322. 1363-5, doi: 10.1126/science.1164446.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.HS1962_minus" href="#MT.HS1962_minus"><code>MT.HS1962_minus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HS1962_minus</code></pre><p>Hashim-Strikman lower bound for mixing 2 phases</p><p><strong>Usage</strong></p><pre><code class="nohighlight hljs">julia&gt; model_mix = construct_mixing_models([1000. + 273., 2e4],
    [:T, :Ch2o_m],
    [0.1],
    [SEO3, Ni2011],
    [HS1962_minus()]
)
julia&gt; log_cond = forward(model_mix, [])</code></pre><p><strong>References</strong></p><p>Paul W. J. Glover (2010), &quot;A generalized Archie&#39;s law for n phases&quot;, Geophysics 2010; 75 (6): E247–E265, doi: https://doi.org/10.1190/1.3509781</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.HS1962_plus" href="#MT.HS1962_plus"><code>MT.HS1962_plus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HS1962_plus</code></pre><p>Hashim-Strikman upper bound for mixing 2 phases</p><p><strong>Usage</strong></p><pre><code class="nohighlight hljs">julia&gt; model_mix = construct_mixing_models([1000. + 273., 2e4]
    [:T, :Ch2o_m]],
    Product([Uniform(0., 1.)]),
    [SEO3, Ni2011],
    [HS1962_minus()]
)
julia&gt; log_cond = forward(model_mix, [])</code></pre><p><strong>References</strong></p><p>Paul W. J. Glover (2010), &quot;A generalized Archie&#39;s law for n phases&quot;, Geophysics 2010; 75 (6): E247–E265. doi: https://doi.org/10.1190/1.3509781</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.Jones2012" href="#MT.Jones2012"><code>MT.Jones2012</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Jones2012(T, Ch2o_ol)</code></pre><p>Electrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> : Temperature of olivine (in K)</li><li><code>Ch2o_ol</code> : water concentration in olivine (in ppm)</li></ul><p><strong>Usage</strong></p><p>julia&gt; model = Jones2012(1000 + 273., 2e4)</p><p>julia&gt; log_cond = forward(model, [])</p><p><strong>References</strong></p><p>Jones, A. G., J. Fullea, R. L. Evans, and M. R. Muller (2012), &quot;Water in cratonic lithosphere: Calibrating laboratory-determined models of electrical conductivity of mantle minerals using geophysical and petrological observations&quot;, Geochem. Geophys. Geosyst., 13, Q06010, doi:10.1029/2012GC004055.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.MAL" href="#MT.MAL"><code>MT.MAL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MAL</code></pre><p>Modified Archie&#39;s law for mixing 2 phases</p><p><strong>Usage</strong></p><pre><code class="nohighlight hljs">julia&gt; model_mix = construct_mixing_models([1000. + 273., 2e4]
    [:T, :Ch2o_m]],
    Product([Uniform(0., 1.)]),
    [SEO3, Ni2011],
    [MAL(1.2)]
)
julia&gt; log_cond = forward(model_mix, [])</code></pre><p><strong>References</strong></p><p>Glover, P. W. J., Hole, M. J., &amp; Pous, J. (2000), &quot;A Modified Archie’s Law for two conducting phases&quot;, Earth and Planetary Science Letters, 180(3–4), 369–383, doi: https://doi.org/10.1016/S0012-821X(00)00168-0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.MTModel" href="#MT.MTModel"><code>MT.MTModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>create a model type for a given resistivity distribution that can be used to calculate forward response for 1d MT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.MTModelDistribution" href="#MT.MTModelDistribution"><code>MT.MTModelDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct modelDistribution{T1&lt;: Union{Distribution, AbstractArray}, T2&lt;: Union{Distribution, AbstractArray}} # where T1,T2 
    m::T1
    h::T2
end</code></pre><p>create a placeholder to store the <code>Distributions.jl</code> sampler for a priori</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.MTResponseDistribution" href="#MT.MTResponseDistribution"><code>MT.MTResponseDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct responseDistribution{T1&lt;: Union{Function, Nothing}, T2&lt;: Union{Function, Nothing}} # where T1,T2
    ρₐ::T1
    ϕ::T2
end</code></pre><p>create a placeholder to store functions to obtain <code>Distributions.jl</code> samplers for the likelihood function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.Ni2011" href="#MT.Ni2011"><code>MT.Ni2011</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ni2011(T, Ch2o_m)</code></pre><p>Electrical conductivity model for basaltic melt dependent on Temperature and water content in melt. For further reading look at the references below.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> : Temperature of melt (should be greater than 1146.8 K)</li><li><code>Ch2o_m</code> : water concentration in melt (in ppm)</li></ul><p><strong>Usage</strong></p><p>julia&gt; model = Ni2011(1000 + 273., 2e4)</p><p>julia&gt; log_cond = forward(model, [])</p><p><strong>References</strong></p><p>Ni, H., Keppler, H. &amp; Behrens, H. (2011), &quot;Electrical conductivity of hydrous basaltic melts: implications for partial melting in the upper mantle.&quot;, Contrib Mineral Petrol 162, 637–650 (2011), doi: https://doi.org/10.1007/s00410-011-0617-4</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.Poe2010" href="#MT.Poe2010"><code>MT.Poe2010</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Poe2010(T, Ch2o_ol)</code></pre><p>Electrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> : Temperature of olivine (in K)</li><li><code>Ch2o_ol</code> : water concentration in olivine (in ppm)</li></ul><p><strong>Usage</strong></p><p>julia&gt; model = Poe2010(1000 + 273., 2e4)</p><p>julia&gt; log_cond = forward(model, [])</p><p><strong>References</strong></p><p>Brent T. Poe, Claudia Romano, Fabrizio Nestola, Joseph R. Smyth (2010), &quot;Electrical conductivity anisotropy of dry and hydrous olivine at 8GPa&quot;, Physics of the Earth and Planetary Interiors,Volume 181, Issues 3–4, 2010, Pages 103-111, ISSN 0031-9201, https://doi.org/10.1016/j.pepi.2010.05.003.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.RockphyModelDistribution" href="#MT.RockphyModelDistribution"><code>MT.RockphyModelDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RockphyModelDistribution{
    T1 &lt;: Union{Distribution, AbstractArray}, T2 &lt;: Union{Distribution, AbstractArray}} &lt;:
            AbstractRockphyModelDistribution
    params::T1 # vector of parameters 
    p_names::Vector{&lt;:Symbol} # Vector of symbols telling the parameters in vector 
    ϕ::T2 # phase ratios
    model_list::Vector{&lt;:Type}
    mixing_type::Vector</code></pre><p>Initializes a placeholder for all the variables to be initialized for use in the <code>stochastic_inverse</code>(@ref stochastic<em>inverse). Has the same structure as `construct</em>mixing<em>models`(@ref construct</em>mixing_models) but instead inputs distributions, and therefore respects the same form.</p><p><strong>Arguments</strong></p><ul><li><code>params</code> : A distribution from <code>Distributions.jl</code> to sample the rock physics parameters.</li><li><code>p_names</code> : The <code>params</code> vector contains the distributions for the parameters specified by the vector of symbols called <code>p_names</code></li><li><code>ϕ</code> : Vol. fraction of different phases (can be a distribution or a vector)</li><li><code>model_list</code> : list of models to be used in mixing</li><li><code>mixing_type</code> : Type of mixing model to be used</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.SEO3" href="#MT.SEO3"><code>MT.SEO3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SEO3(T)</code></pre><p>Electrical conductivity model for olivine dependent on temperature. </p><p>For further reading look at the references below.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `T` : Temperature of olivine (in K)</code></pre><p><strong>Usage</strong></p><pre><code class="nohighlight hljs">julia&gt; model = SEO3(1000 + 273.)

julia&gt; log_cond = forward(model, [])</code></pre><p><strong>References</strong></p><p>Constable, S (2006), &quot;SEO3: A new model of olivine electrical conductivity&quot;, Geophysical Journal International, Volume 166, Issue 1, July 2006, Pages 435–437, https://doi.org/10.1111/j.1365-246X.2006.03041.x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.Sifre2014" href="#MT.Sifre2014"><code>MT.Sifre2014</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sifre2014(T, Ch2o_m, Cco2_m)</code></pre><p>Electrical conductivity model for melt dependent on Temperature, water content and CO₂ content in melt. For further reading look at the references below.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> : Temperature of melt (should be greater than 1146.8 K)</li><li><code>Ch2o_m</code> : water concentration in melt (in ppm)</li><li><code>Cco2_m</code> : Co2 concentration in melt (in ppm)</li></ul><p><strong>Usage</strong></p><p>julia&gt; model = Sifre2014(1000 + 273., 2e4, 2e4)</p><p>julia&gt; log_cond = forward(model, [])</p><p><strong>References</strong></p><p>Sifré, D., Gardés, E., Massuyeau, M. et al. (2014), &quot;Electrical conductivity during incipient melting in the oceanic low-velocity zone.&quot; Nature 509, 81–85 (2014), doi: https://doi.org/10.1038/nature13245</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.UHO2014" href="#MT.UHO2014"><code>MT.UHO2014</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UHO2014(T, Ch2o_ol)</code></pre><p>Electrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> : Temperature of olivine (in K)</li><li><code>Ch2o_ol</code> : water concentration in olivine (in ppm)</li></ul><p><strong>References</strong></p><p>Gardés, E., F. Gaillard, and P. Tarits (2014), &quot;Toward a unified hydrous olivine electrical conductivity law&quot;, Geochem. Geophys. Geosyst., 15, 4984–5000, doi:10.1002/2014GC005496.</p><p><strong>Usage</strong></p><pre><code class="nohighlight hljs">julia&gt; model = UHO2014(1000 + 273., 2e4)

julia&gt; log_cond = forward(model, [])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.Wang2006" href="#MT.Wang2006"><code>MT.Wang2006</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Wang2006(T, Ch2o_ol)</code></pre><p>Electrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> : Temperature of olivine (in K)</li><li><code>Ch2o_ol</code> : water concentration in olivine (in ppm)</li></ul><p><strong>Usage</strong></p><p>julia&gt; model = Wang2006(1000 + 273., 2e4)</p><p>julia&gt; log_cond = forward(model, [])</p><p><strong>References</strong></p><p>Wang, D., Mookherjee, M., Xu, Y. et al. (2006), &quot;The effect of water on the electrical conductivity of olivine&quot;, Nature 443, 977–980 (2006), doi: https://doi.org/10.1038/nature05256</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.Yoshino2009" href="#MT.Yoshino2009"><code>MT.Yoshino2009</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Yoshino2009(T, Ch2o_ol)</code></pre><p>Electrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> : Temperature of olivine (in K)</li><li><code>Ch2o_ol</code> : water concentration in olivine (in ppm)</li></ul><p><strong>Usage</strong></p><p>julia&gt; model = Yoshino2009(1000 + 273., 2e4)</p><p>julia&gt; log_cond = forward(model, [])</p><p><strong>References</strong></p><p>Takashi Yoshino, Takuya Matsuzaki, Anton Shatskiy, Tomoo Katsura (2009), &quot;The effect of water on the electrical conductivity of olivine aggregates and its implications for the electrical structure of the upper mantle, Earth and Planetary Science Letters&quot;, Volume 288, Issues 1–2, 2009, Pages 291-300, ISSN 0012-821X, https://doi.org/10.1016/j.epsl.2009.09.032.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.const_matrix" href="#MT.const_matrix"><code>MT.const_matrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const_matrix(σ)</code></pre><p>Fixed electrical conductivity model for the phase.</p><p><strong>Arguments</strong></p><ul><li><code>σ</code> : Conductivity of the phase</li></ul><p><strong>Usage</strong></p><p>julia&gt; model = const_matrix(1000.)</p><p>julia&gt; log_cond = forward(model, [])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.inverse_utils" href="#MT.inverse_utils"><code>MT.inverse_utils</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct inverse_utils</code>: contains the utilities for inversion, once initialized, will not be updated in the inversion iterations <code>D</code>: second derivative operator, <code>W</code>: weight matrix, <code>dobs</code>: data response to be inverted for.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.linear_utils" href="#MT.linear_utils"><code>MT.linear_utils</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct linear_utils</code>: contains the utilities for linearizing the forward model =&gt; <code>mₖ</code>:model, <code>Fₖ</code>: Forward response at <code>mₖ</code>, <code>Jₖ</code>: Jacobian at <code>mₖ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.mcmc_cache" href="#MT.mcmc_cache"><code>MT.mcmc_cache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct struct mcmc_cache{T1 &lt;: AbstractGeophyModelDistribution, T2 &lt;: AbstractGeophyResponseDistribution}
    apriori::T1
    likelihood::T2
    n_samples::Int
    sampler
end</code></pre><p>placeholder to store</p><ul><li>apriori in the form of any subtype of <a href="api.html#MT.AbstractModelDistribution"><code>AbstractModelDistribution</code></a></li><li>likelihood in the form of any subtype of <a href="api.html#MT.AbstractResponseDistribution"><code>AbstractResponseDistribution</code></a></li><li>number of samples to obtain in <code>n_samples</code></li><li><code>Turing.jl</code> sampler to be used in <code>sampler</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.mixing_models" href="#MT.mixing_models"><code>MT.mixing_models</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mixing_models</code></pre><p>constructs a <code>mixing_models</code> type which can then be used to do rock physics modeling. Should be called using <code>construct_mixing_models</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.nl_cache" href="#MT.nl_cache"><code>MT.nl_cache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>nl_cache</code>: specifies the inverse algorithm while having a cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.occam_cache" href="#MT.occam_cache"><code>MT.occam_cache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>occam_cache</code>: specifies the inverse algorithm while having a cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.opt_cache" href="#MT.opt_cache"><code>MT.opt_cache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>nl_cache</code>: specifies the inverse algorithm while having a cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.return_code" href="#MT.return_code"><code>MT.return_code</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>struct return_code</code>: contains the information if the inversion was successful</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.rto_cache" href="#MT.rto_cache"><code>MT.rto_cache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rto_cache(m₀, μgrid, alg, max_iters, n_samples, χ2, response_fields, L, verbose)</code></pre><p>returns <code>rto_cache</code> that specifies the algorithm to be used for stochastic inversion using RTO-TKO</p><p><strong>Arguments</strong></p><ul><li><code>m₀</code>: <code>model</code>, usually a starting value to start inversion but mostly to allocate memory space</li><li><code>μgrid</code>: prior space of μ</li><li><code>alg</code>: type of algorithm for optimization step, choices include (<code>occam_cache</code>)[@ref], (<code>nl_cache</code>)[@ref], and (<code>opt_cache</code>)[@ref]</li><li><code>max_iters</code>: maximum iterations for the optimization scheme</li><li><code>n_samples</code>: number of samples to be obtained. Note: If there are any spurious samples (say <code>NaN</code> values), they will be automatically deleted, reducing the sample size</li><li><code>χ2</code>: target misfit</li><li><code>response_fields</code>: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)</li><li><code>L</code>: Regularization matrix, defaults to discretized derivative matrix given by ∂(@ref)</li><li><code>verbose</code>: to print results or not</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.single_phase" href="#MT.single_phase"><code>MT.single_phase</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">single_phase</code></pre><p>Single phase only conductivity. Assumes the rock matrix is composed of a single phase only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MT.transform_utils-Union{Tuple{T}, Tuple{Vector{T}, Function, Function, Function}} where T&lt;:Union{Float32, Float64}" href="#MT.transform_utils-Union{Tuple{T}, Tuple{Vector{T}, Function, Function, Function}} where T&lt;:Union{Float32, Float64}"><code>MT.transform_utils</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>transform_utils</code>: Contains the parameters and functions for transformation from optimization to model domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ayushinav/MT">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="vizualization.html">« Vizualization</a><a class="docs-footer-nextpage" href="working_with_mtpy.html">mtpy tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 16 April 2025 21:03">Wednesday 16 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
