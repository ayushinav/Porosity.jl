<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Deterministic Inverse · MT.jl</title><meta name="title" content="Deterministic Inverse · MT.jl"/><meta property="og:title" content="Deterministic Inverse · MT.jl"/><meta property="twitter:title" content="Deterministic Inverse · MT.jl"/><meta name="description" content="Documentation for MT.jl."/><meta property="og:description" content="Documentation for MT.jl."/><meta property="twitter:description" content="Documentation for MT.jl."/><meta property="og:url" content="https://ayushinav.github.io/MT/deterministic_inverse.html"/><meta property="twitter:url" content="https://ayushinav.github.io/MT/deterministic_inverse.html"/><link rel="canonical" href="https://ayushinav.github.io/MT/deterministic_inverse.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">MT.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="model.html">model</a></li><li><a class="tocitem" href="forward.html">forward</a></li><li class="is-active"><a class="tocitem" href="deterministic_inverse.html">Deterministic Inverse</a><ul class="internal"><li><a class="tocitem" href="#Brief-introduction"><span>Brief introduction</span></a></li><li><a class="tocitem" href="#Demo"><span>Demo</span></a></li><li><a class="tocitem" href="#Fits"><span>Fits</span></a></li></ul></li><li><a class="tocitem" href="domain_transformation.html">domain transformation</a></li><li><a class="tocitem" href="interface_guide.html">interface guide</a></li><li><span class="tocitem">Probabilistic inverse</span><ul><li><a class="tocitem" href="probabilistic_inverse.html">Interface</a></li><li><a class="tocitem" href="tutorials/fixed_discretization.html">MCMC with fixed discretization</a></li><li><a class="tocitem" href="tutorials/variable_discretization.html">MCMC with variable discretization</a></li><li><a class="tocitem" href="tutorials/rto.html">RTO-TKO</a></li><li><a class="tocitem" href="rock_physics.html">rock physics</a></li></ul></li><li><a class="tocitem" href="vizualization.html">Vizualization</a></li><li><a class="tocitem" href="api.html">API</a></li><li><a class="tocitem" href="working_with_mtpy.html">mtpy tutorial</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="deterministic_inverse.html">Deterministic Inverse</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="deterministic_inverse.html">Deterministic Inverse</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ayushinav/MT" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Deterministic-Inversion"><a class="docs-heading-anchor" href="#Deterministic-Inversion">Deterministic Inversion</a><a id="Deterministic-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Deterministic-Inversion" title="Permalink"></a></h1><h2 id="Brief-introduction"><a class="docs-heading-anchor" href="#Brief-introduction">Brief introduction</a><a id="Brief-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Brief-introduction" title="Permalink"></a></h2><p>Inverse problems in geophysics are notoriously ill-posed with non-unique solutions. MT inversion is no different. Below we demonstrate how we can perform different non-linear inverse schemes on a synthetic dataset.</p><h2 id="Demo"><a class="docs-heading-anchor" href="#Demo">Demo</a><a id="Demo-1"></a><a class="docs-heading-anchor-permalink" href="#Demo" title="Permalink"></a></h2><p>We start with defining models:</p><pre><code class="language-julia hljs">using MT, LinearAlgebra, CairoMakie

ρ= log10.([100., 10., 400., 1000.])
h= [100., 1000., 10000.]
m= MTModel(ρ, h)

T= 10 .^(range(-1,5,length= 19))
ω= 2π./T

f, ax = plot_model(m)
ax.xscale = log10
ax.yscale = log10
f</code></pre><img src="deterministic_inverse-08070993.png" alt="Example block output"/><p>and getting data, with a 10% error floor.</p><pre><code class="language-julia hljs">resp= forward(m, ω)

err_resp = MTResponse(
    0.1 .* resp.ρₐ,
    180/π .* asin(0.1) .+ zero(ω)
    )

f, axs = plot_response(ω, resp, label= &quot;observed&quot;, plt_type = :scatter)
plot_response!(axs, ω, resp, errs = err_resp, label= &quot;observed&quot;, plt_type = :errors, whiskerwidth = 10)
f</code></pre><img src="deterministic_inverse-d416af2a.png" alt="Example block output"/><p>It&#39;s time to perform a few inversion schemes. All the inversion schemes can be called by the same function call, with just the difference of making an <code>alg_cache</code>, which mostly just depends on the library to be called for the non-linear inverse problem.</p><h3 id="Occam"><a class="docs-heading-anchor" href="#Occam">Occam</a><a id="Occam-1"></a><a class="docs-heading-anchor-permalink" href="#Occam" title="Permalink"></a></h3><p>Performing occam essentially boils down to making an <code>occam_cache</code>, which is done by making a call to <a href="deterministic_inverse.html#Occam"><code>Occam</code></a>.</p><pre><code class="language-julia hljs">W = diagm(inv.([err_resp.ρₐ..., err_resp.ϕ...])) .^ 2; # weight matrix

h_test= 10 .^range(0., 5., length= 50)
ρ_test= 2 .*ones(length(h_test)+1)

m_occam= MTModel(ρ_test, h_test);

alg_cache = Occam(; μgrid=[1e-2, 1e6])
inverse!(m_occam, resp, ω, alg_cache, W = W; max_iters= 50, verbose = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MT.return_code{MTModel{Vector{Float64}, Vector{Float64}}}(true, (μ = 1.067910683596915,), MTModel{Vector{Float64}, Vector{Float64}}([1.5270067289628448, 1.5265705948767971, 1.525585504562895, 1.5239091442691217, 1.5213618686302937, 1.5177167465575758, 1.5126869525900766, 1.505909892926149, 1.4969274817378029, 1.4851622841699532  …  2.969639557515583, 2.969467273602941, 2.968996756614226, 2.9690612539818844, 2.9694393066210854, 2.9695939368746425, 2.9693586814705615, 2.9691735058212805, 2.9698383210153487, 2.9720757147791463], [1.0, 1.2648552168552962, 1.599858719606058, 2.023589647725157, 2.5595479226995357, 3.237457542817644, 4.094915062380426, 5.179474679231212, 6.551285568595509, 8.286427728546844  …  12067.92640639329, 15264.179671752334, 19306.977288832495, 24420.5309454865, 30888.435964774784, 39069.39937054621, 49417.13361323838, 62505.51925273976, 79060.43210907701, 100000.0]), 1.0, 0.9531056622151755)</code></pre><h3 id="Levenberg-Marquadt"><a class="docs-heading-anchor" href="#Levenberg-Marquadt">Levenberg-Marquadt</a><a id="Levenberg-Marquadt-1"></a><a class="docs-heading-anchor-permalink" href="#Levenberg-Marquadt" title="Permalink"></a></h3><p>While Occam is implemented in the package, we borrow a few from other packages. One of them is <code>NonlinearSolve.jl</code>, where we have <code>Levenberg-Marquadt</code> scheme. Again, everything boils down to creating the <code>alg_cache</code>. You can use <a href="https://docs.sciml.ai/NonlinearSolve/stable/solvers/nonlinear_least_squares_solvers/">other solvers</a> from the package as well.</p><pre><code class="language-julia hljs">using NonlinearSolve

h_test= 10 .^range(0., 5., length= 50)
ρ_test= 2. .*ones(length(h_test)+1)

resp_trans_utils = (ρₐ=MT.log_tf, ϕ=MT.phi_scale_tf);

resp_lm = MTResponse(
    resp_trans_utils[:ρₐ].tf.(resp.ρₐ),
    resp_trans_utils[:ϕ].tf.(resp.ϕ),
)

err_resp_lm = MTResponse(
    resp_trans_utils[:ρₐ].dtf.(resp.ρₐ) .* err_resp.ρₐ,
    resp_trans_utils[:ϕ].dtf.(resp.ϕ) .* err_resp.ϕ,
)

m_lm= MTModel(ρ_test, h_test);

W_lm = diagm(inv.([err_resp_lm.ρₐ..., err_resp_lm.ϕ...])) .^ 2; # weight matrix

alg_cache =  NonlinearAlg(; alg = TrustRegion, μ = 1.0)
inverse!(m_lm, resp, ω, alg_cache; W =W_lm, max_iters= 20, verbose = true, response_trans_utils = (ρₐ=MT.log_tf, ϕ=MT.phi_scale_tf))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MT.return_code{MTModel{Vector{Float64}, Vector{Float64}}}(false, (μ = 1.0,), MTModel{Vector{Float64}, Vector{Float64}}([2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0  …  2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0], [1.0, 1.2648552168552962, 1.599858719606058, 2.023589647725157, 2.5595479226995357, 3.237457542817644, 4.094915062380426, 5.179474679231212, 6.551285568595509, 8.286427728546844  …  12067.92640639329, 15264.179671752334, 19306.977288832495, 24420.5309454865, 30888.435964774784, 39069.39937054621, 49417.13361323838, 62505.51925273976, 79060.43210907701, 100000.0]), 1.0, 8785.867061962686)</code></pre><h3 id="LBFGS"><a class="docs-heading-anchor" href="#LBFGS">LBFGS</a><a id="LBFGS-1"></a><a class="docs-heading-anchor-permalink" href="#LBFGS" title="Permalink"></a></h3><p>Another popular algorithm is LBFGS, which we borrow from <code>Optimization.jl</code>. Again, create the <code>alg_cache</code> and it&#39;s good to go. <code>Optimization.jl</code> provides a <a href="https://docs.sciml.ai/Optimization/stable/#Overview-of-the-solver-packages-in-alphabetical-order">suite of solvers</a>, also by wrapping around a few others.</p><pre><code class="language-julia hljs">using Optimization, OptimizationOptimJL

h_test= 10 .^range(0., 5., length= 50)
ρ_test= m_occam.m .+ 1 .* randn(length(h_test) + 1)

resp_trans_utils = (ρₐ=MT.log_tf, ϕ=MT.phi_scale_tf);

resp_lbfgs = MTResponse(
    resp_trans_utils[:ρₐ].tf.(resp.ρₐ),
    resp_trans_utils[:ϕ].tf.(resp.ϕ),
)

err_resp_lbfgs = MTResponse(
    resp_trans_utils[:ρₐ].dtf.(resp.ρₐ) .* err_resp.ρₐ,
    resp_trans_utils[:ϕ].dtf.(resp.ϕ) .* err_resp.ϕ,
)

m_lbfgs= MTModel(ρ_test, h_test);

W_lbfgs = diagm(inv.([err_resp_lbfgs.ρₐ..., err_resp_lbfgs.ϕ...])) .^ 2; # weight matrix

alg_cache =  OptAlg(; alg = LBFGS, μ = 1.0)
inverse!(m_lbfgs, resp, ω, alg_cache, W = W_lbfgs; max_iters= 50, verbose = true, response_trans_utils = (ρₐ=MT.log_tf, ϕ=MT.phi_scale_tf))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MT.return_code{MTModel{Vector{Float64}, Vector{Float64}}}(false, (μ = 1.0,), MTModel{Vector{Float64}, Vector{Float64}}([6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0  …  6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0], [1.0, 1.2648552168552962, 1.599858719606058, 2.023589647725157, 2.5595479226995357, 3.237457542817644, 4.094915062380426, 5.179474679231212, 6.551285568595509, 8.286427728546844  …  12067.92640639329, 15264.179671752334, 19306.977288832495, 24420.5309454865, 30888.435964774784, 39069.39937054621, 49417.13361323838, 62505.51925273976, 79060.43210907701, 100000.0]), 1.0, 8738.239797905037)</code></pre><h2 id="Fits"><a class="docs-heading-anchor" href="#Fits">Fits</a><a id="Fits-1"></a><a class="docs-heading-anchor-permalink" href="#Fits" title="Permalink"></a></h2><p>So how well do we fit the data? Note that, in no way we compare the different inversion schemes here. A lot of these schemes depend heavily on the initial model and our choice might be sub-optimal.</p><pre><code class="language-julia hljs">resp_occam= forward(m_occam, ω);
resp_lm= forward(m_lm, ω);
resp_lbfgs= forward(m_lbfgs, ω);

f, axs = plot_response(ω, resp, errs = err_resp, plt_type = :errors, whiskerwidth= 10,)
plot_response!(axs, ω, resp, plt_type = :scatter, label= &quot;true&quot;)
plot_response!(axs, ω, resp_occam, label= &quot;occam&quot;, plt_type = :plot, color = :magenta)
plot_response!(axs, ω, resp_lm, label= &quot;Levenberg-Marquadt&quot;, plt_type = :plot, linewidth= 2)
plot_response!(axs, ω, resp_lbfgs, label= &quot;LBFGS&quot;, plt_type = :plot, linewidth= 2)

f[2,2] = Legend(f, axs[1])
f</code></pre><img src="deterministic_inverse-b9b391c2.png" alt="Example block output"/><p>And a look at different models</p><pre><code class="language-julia hljs">f, ax = plot_model(m, label = &quot;true&quot;, linewidth = 3, color = &quot;black&quot;)
plot_model!(ax, m_occam, label = &quot;occam&quot;, linewidth = 2, color = &quot;blue&quot;)
plot_model!(ax, m_lm, label = &quot;Levenberg-Marquadt&quot;, linewidth = 2)
plot_model!(ax, m_lbfgs, label = &quot;LBFGS&quot;, linewidth = 2)

# axislegend(ax, position = :rb)
ax.xscale = log10
ax.yscale = log10

f[1,2] = Legend(f, axs[1])
f</code></pre><img src="deterministic_inverse-b0e7fb1d.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="forward.html">« forward</a><a class="docs-footer-nextpage" href="domain_transformation.html">domain transformation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 16 April 2025 21:03">Wednesday 16 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
