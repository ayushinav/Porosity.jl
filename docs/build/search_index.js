var documenterSearchIndex = {"docs":
[{"location":"domain_transformation.html#Domain-transformation","page":"domain transformation","title":"Domain transformation","text":"","category":"section"},{"location":"domain_transformation.html#Introduction","page":"domain transformation","title":"Introduction","text":"","category":"section"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"Throughout the framework, you will come across transform_utils, whether be it deterministic inverse, or probabilistic. Even in simple forward calculations, we have them embedded. ","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"Firstly, let's understand its structure with the example of log_tf. A transform_utils type variable, say trans_util has 4 parameters, the second of which, referred by tf is used to move from one space to another. For consistency, we call this forward transformation, that is, it will move the variables to the log-space (on the base 10). ","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"x = 10.\nlog_tf.tf(x) ## = 1.","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"Then we have inverse transformation given by itf, and it will allow you to get the values back.","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"x = 2.\nlog_tf.tf(x) ## = 100.","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"We, then also have dtf, which computes the derivative of the forward tramnsformation","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"x = 10.\nlog_tf.tf(x) ## ","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"We also have p which is a vector to parameterize these functions if needed, eg., sigmoid_tf has p which define the lower and upper bounds of the scaled sigmoid. This is used in bounding variables without putting an explicit constraint on them.","category":"page"},{"location":"domain_transformation.html#Model-transformation","page":"domain transformation","title":"Model transformation","text":"","category":"section"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"Model transformation is where these transformations really help. As an eg., for MT inversion, we want our bounds of log resistivity to be between -1 and 3. We then define a new transform_utils variable as:","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"my_trans_util = transform_utils([-1.0, 3.0], sigmoid, inverse_sigmoid, d_sigmoid);","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"and then pass this in the model_transform_utils parameter of the functions such as inverse!, stochastic_inverse and many others.","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"Explain that this should mostly be used for bounding, example of regularization.","category":"page"},{"location":"domain_transformation.html#Response-transformation","page":"domain transformation","title":"Response transformation","text":"","category":"section"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"Similar to model_trans_utils, a lot of functions, including forward have the option to pass in response_trans_utils. The working is fairly similar in the aspect that we transform the data. This can be useful in inversion schemes when we have data in different varying in different domains, eg. apparent resistivity varying smoothly on the log-scale and phase on the linear scale. ","category":"page"},{"location":"domain_transformation.html","page":"domain transformation","title":"domain transformation","text":"Explain how data to be given should already be in the transformed space","category":"page"},{"location":"tutorials/variable_discretization.html#Variable-discretization","page":"MCMC with variable discretization","title":"Variable discretization","text":"","category":"section"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"Especially in 1D, we have an analytical solution to the model with any grid spacing. This allows us to move the layer interfaces up and down while parameterizing the model space in a different way wherein there is more flexibility.","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"Let's denote the model parameters, eg., conductivity, by m, and the layer thickness by h. Therefore, in a N-layer case, we will have ","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"m = m_1 m_2 m_3   m_N \nh = h_1 h_2 h_3   h_N_1","category":"page"},{"location":"tutorials/variable_discretization.html#Copy-Pasteable-code","page":"MCMC with variable discretization","title":"Copy-Pasteable code","text":"","category":"section"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"using MT\nusing Distributions\nusing Turing\nusing LinearAlgebra\n\nm_test = MTModel(log10.([100., 10., 1000.]), [1e3, 1e3]);\nf = 10 .^ range(-4, stop = 1, length = 25);\nω = vec(2π .* f);\n\nr_obs = forward(m_test, ω);\nerr_phi = asin(0.01) * 180/π .* ones(length(ω));\nerr_appres = 0.02 * r_obs.ρₐ;\nerr_resp = MTResponse(err_appres, err_phi);\n\nr_obs.ρₐ .= r_obs.ρₐ .+ randn(length(ω)) .* err_appres;\nr_obs.ϕ .= r_obs.ϕ .+ randn(length(ω)) .* err_phi;\n\nrespD = MTResponseDistribution(normal_dist, normal_dist);\n\nz = 10 .^collect(range(1, stop = 4, length = 100));\nh = diff(z);\n\nmodelD = MTModelDistribution(\n    Product(\n        [Uniform(-1, 5) for i in 1:n]\n    ),\n    Product(\n        [Uniform(15, 25) for i in 1:(n-1)]\n    )\n);\n\nn_samples = 50;\nmcache = mcmc_cache(modelD, respD, 50, NUTS());\n\nmt_chain = stochastic_inverse(r_obs, err_resp, ω, mcache)","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"The obtained mt_chain contains the distributions that can be saved using JLD2.jl.","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"using JLD2\nJLD2.@save \"file_path.jld2\" mt_chain","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"Note: ","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"note: Note\nThe returned chains will be sampled in the distribution specified by modelD. In the presented case, it will have values in -1 5 and we can get the values by 10. ^ value.","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"The list of models can then be obtained from chains using","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"model_list = get_model_list(mt_chain, modelD)","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"We can then easily check the fit of the response curves","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"plt_resps = prepare_plot(r_obs, ω, alpha = 0.);\nresp_models = forward(model_list[1], ω);\n\nfor i in 1:(length(model_list) > 50 ? 50 : length(model_list))\n   forward!(resp_models, model_list[i], ω);\n   prepare_plot!(resp_models, ω, alpha = 0.4); \nend\n\nprepare_plot!(r_obs, ω, d_err = err_resp, markersize = 3, color = :orange);\nplot_response(plt_resps)","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"The posterior distribution can then be obtained as:","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"pre_img = pre_image(m_dist, mt_chain);\nkde_img = get_kde_image(pre_img..., false, xscale = :identity, yscale = :identity, yflip = true)","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"We can also obtain the mean and 1 std deviation bounds as:","category":"page"},{"location":"tutorials/variable_discretization.html","page":"MCMC with variable discretization","title":"MCMC with variable discretization","text":"mean_std_plt_lin = get_mean_std_image(pre_img..., yscale = :identity)","category":"page"},{"location":"forward.html#Forward-modeling","page":"forward","title":"Forward modeling","text":"","category":"section"},{"location":"forward.html#Demo","page":"forward","title":"Demo","text":"","category":"section"},{"location":"forward.html","page":"forward","title":"forward","text":"Currently, only the recursion solution for MT forward modeling is supported. Once a model is defined, we can get the estimate as:","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"using MT, CairoMakie\nρ= log10.([500., 100., 400., 1000.]);\nh= [100., 1000., 10000.];\nm= MTModel(ρ, h)\n\nT= 10 .^(range(-1,5,length= 57));\nω= 2π./T;\n\nresp= forward(m, ω);\nnothing # hide","category":"page"},{"location":"forward.html#Plots","page":"forward","title":"Plots","text":"","category":"section"},{"location":"forward.html","page":"forward","title":"forward","text":"Since MT MTResponse has two fields, and we also want to see the curves for other MTModels, usually for inversion:","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"f, axs= plot_response(ω, resp, label = \"1st\")\nf","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"Another MTResponse can be overlain using:","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"ρ= log10.([100., 10., 400.]);\nh= [100., 10000.];\nm2= MTModel(ρ, h)\nresp2= forward(m2, ω)\nplot_response!(axs, ω, resp2, label=\"2nd\")\n\nf[2,2] = Legend(f, axs[1])\nf","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"Note that we've plotted the second response curve as a line, which can simply be achieved by passing plt_type = :plot","category":"page"},{"location":"forward.html#Benchmark","page":"forward","title":"Benchmark","text":"","category":"section"},{"location":"forward.html","page":"forward","title":"forward","text":"In-place operations for fast non-allocating computations are also supported. These would greatly speed up the inverse processes.","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"using BenchmarkTools\n@benchmark forward!(resp, m, ω)","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"The above benchmark was done on Mac M1.","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"If we want, we can get the data on a different scale ((using domain transformation)[domain_transformation.md]) than is provided by default using `:","category":"page"},{"location":"forward.html","page":"forward","title":"forward","text":"ρ= log10.([500., 100., 400., 1000.]);\nh= [100., 1000., 10000.];\nm= MTModel(ρ, h)\n\nT= 10 .^(range(-1,5,length= 57));\nω= 2π./T;\n\nresp= forward(m, ω, (ρₐ=log_tf, ϕ=lin_tf));\nf, ax = plot_response(ω, resp, label = false)\nf","category":"page"},{"location":"rock_physics.html#Rock-physics","page":"rock physics","title":"Rock physics","text":"","category":"section"},{"location":"rock_physics.html#Models","page":"rock physics","title":"Models","text":"","category":"section"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"We support the following rock physics models to obtain the electrical conductivity of the rock:","category":"page"},{"location":"rock_physics.html#Minerals","page":"rock physics","title":"Minerals","text":"","category":"section"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"SEO3 : Constable, 2006 : SEO3: A new model of olivine electrical conductivity\nUHO2014 : Gardés et al., 2014 : Toward a unified hydrous olivine electrical conductivity law\nJones2012 : Jones et al., 2012 : Calibrating laboratory-determined models of electrical conductivity of mantle minerals using geophysical and petrological observations\nPoe2010 : Poe et al., 2010 : Electrical conductivity anisotropy of dry and hydrous olivine at 8GPa\nWang2006 : Wang et al., 2006 : The effect of water on the electrical conductivity of olivine\nYoshino2009 : Yoshino et al., 2009 :The effect of water on the electrical conductivity of olivine aggregates and its implications for the electrical structure of the upper mantle\nconst_matrix : The solid matrix is assumed to be of constant bulk conductivity","category":"page"},{"location":"rock_physics.html#Melt","page":"rock physics","title":"Melt","text":"","category":"section"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"Ni2011 : Ni et al., 2011 : Electrical conductivity of hydrous basaltic melts: implications for partial melting in the upper mantle\nSifre2014 : Sifre et al., 2014 : Electrical conductivity during incipient melting in the oceanic low-velocity zone\nGaillard2008 : Gaillard et al., 2008 : Carbonatite Melts and Electrical Conductivity in the Asthenosphere","category":"page"},{"location":"rock_physics.html#Forward-calculations","page":"rock physics","title":"Forward calculations","text":"","category":"section"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"Forward calculations are fairly easy and involve calling forward function on the model. Following is an example on how we can get the conductivity using Poe2010:","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"using MT\nmodel_poe = Poe2010(1000 + 273., 2e4)\n\nlog_cond = forward(model_poe, [])","category":"page"},{"location":"rock_physics.html#Mixing-phases","page":"rock physics","title":"Mixing phases","text":"","category":"section"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"We can also mix in melt and use the following mixing schemes to get the bulk conductivity: ","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"HS1962_plus : Hashim-Strikman upper bound for 2 phases\nHS1962_minus : Hashim-Strikman lower bound for 2 phases\nMAL : Modified Archie's law\nsingle_phase : Bulk rock is composed of one material","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"Below we estimate the bulk conductivity of rock with solid phase conductivity governed by SEO3 and melt by Ni2011. We'll assume a porosity of 0.1 and calculate the upper HS bounds for the matrix. ","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"\nmix1 = construct_mixing_models([1000 + 273., 2e4], [:T, :Ch2o_m],\n    [0.1], [SEO3, Ni2011], [HS1962_plus()])\n\nlog_cond_mix = forward(mix1, [])","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"Note: ","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"note: Note\nEven when you have a single phase, the use of construct_mixing_models is recommended using single_phase mixing scheme. Make sure to then have ϕ = 1..\nmix_single = construct_mixing_models([1000 + 273., 2e4], [:T, :Ch2o_ol],\n    [1.], [UHO2014], [single_phase()])\n\nlog_cond = forward(mix_single, [])","category":"page"},{"location":"rock_physics.html#Stochastic-inversion","page":"rock physics","title":"Stochastic inversion","text":"","category":"section"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"Now that we know how to compute the rock physics responses, we move towards performing stochastic inversion for rock physics parameters given some rock conductivity and the corresponding uncertainty.s","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"using Distributions\nusing StatsPlots\nusing Turing\n# define a rock physics distribution to sample parameters from\nm_dist = RockphyModelDistribution(\n    Product([\n        Uniform(1173., 1573.),\n        Uniform(1e2, 3e4),\n    ]),\n    [:T, :Ch2o_m],\n    Product([Uniform(0.,0.4)]),\n    [SEO3, Ni2011],\n    [HS1962_plus()]\n)","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"RockphyModelDistribution allows us to define the a priori distribution for rock physics parameters. If the user wants to keep a certain parameter constant, they should define the range of a priori distribution as very small, eg., if, in the above, we want to keep water content in melt CH2o_m constant, we define it's a apriori as a narrow range as","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"m_dist = RockphyModelDistribution(\n    Product([\n        Uniform(1173., 1573.),\n        Uniform(2e4-1, 2e4+1), # Keeping Ch2o_m almost fix around 2e4\n    ]),\n    [:T, :Ch2o_m],\n    Product([Uniform(0.,0.4)]),\n    [SEO3, Ni2011],\n    [HS1962_plus()]\n)","category":"page"},{"location":"rock_physics.html","page":"rock physics","title":"rock physics","text":"r_dist = RockphyResponseDistribution((x,y) -> MultivariateNormal(x,y))\n\nm_cache = mcmc_cache(\n    m_dist,\n    r_dist,\n    50_000,\n    MH()\n)\n\n# rock physics response\nrp_obs = RockphyCond(log_cond_mix.σ)\nerr_rp = RockphyCond(log_cond_mix.σ .* 0.01)\n\nsamples = stochastic_inverse(rp_obs, err_rp, [], m_cache) #, trans_utils=(m=log_tf,))\n\nplot(samples)","category":"page"},{"location":"probabilistic_inverse.html#Probabilistic-inversion","page":"Interface","title":"Probabilistic inversion","text":"","category":"section"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"Performing stochastic inversion involves forming the model prior space, defining the likelihood and then getting samples from the posterior space. ","category":"page"},{"location":"probabilistic_inverse.html#Constructing-distributions-to-sample-from","page":"Interface","title":"Constructing distributions to sample from","text":"","category":"section"},{"location":"probabilistic_inverse.html#Model-distribution-(*a-priori*-information)","page":"Interface","title":"Model distribution (a priori information)","text":"","category":"section"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"Before beginning to talk about how to construct the a priori distribution, it is important to understand that the model here refers to the discretization space as well as the values of physical properties. For eg, for electrical methods, the model space will consist of the electrical resistivity as well as the grid sizes represented by those. This is primarily useful in 1D, but can have its own consequences.","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"For most applications, however, we fix the node points. We follow a 1D MT example to show the framework. For now, we begin by choosing a very broad prior for all the n layers. A model distribution can be constructed using MTModelDistribution(...). This has the same structure as MTModel, that is, the first parameter denotes the prior for electrical conductivities, while the second is for the layer thicknesses h. If you do not want to infer on h, just pass it as a simple vector, as is also demonstrated in the following case:","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"n = 50 # number of layers\nh = fill(20., n-1) # making the discretization\n\n# prior space with fixed model discretization\nmodelD = MTModelDistribution(\n    Product(\n    [Uniform(-1, 5) for i in 1:n]\n    ),\n    vec(h) # fixed h\n);","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"Some of the things to understand here are :","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"Product(...) is a Distributions.jl function that joins a series of multivariate/univariate samples, here Uniform(-1,5). Thus, Product([Uniform(-1, 5) for in 1:n]) makes a sampler that will output an n-length vector, with each element sampled from Uniform(-1,5). Here, we use a uniform prior, but one can choose any prior. The only thing to keep in mind is that the prior can be sampled, that is, rand(modelD.m) returns a vector of appropriate length. Another eg., would be MultivariateNormal(μ, Σ).\nTo also sample h, pass another multivariate distribution that outputs n-1 length vector. Again using a uniform, independent prior, we'll have:","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"\n# prior space with variable model discretization\nmodelD = MTModelDistribution(\n    Product(\n        [Uniform(-1, 5) for i in 1:n]\n    ),\n    Product(\n        [Uniform(15, 25) for i in 1:(n-1)]\n    )\n);\n","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"This has its own consequences on the results and one needs to be mindful of that while interpreting the results.","category":"page"},{"location":"probabilistic_inverse.html#Response-distribution-(*likelihood*)","page":"Interface","title":"Response distribution (likelihood)","text":"","category":"section"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"A likelihood is determined by an observed response r_obs we want to fit, and the errors associated with it err_resp. One of the popular ways in which likelihood can be formed is using the gaussian distribution, centered around r_obs with variance given by err_resp. To make things consistent, we pass r_obs and err_resp into the final function. To make a likelihood, we just need to pass a function that can take in a response parameter and the associated error and produce a distribution. We already provide a function norm_dist that takes in a vector for the response and another vector/matrix for the covariance matrix of the errors. The response distribution is then constructed by:","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"respD = MTResponseDistribution(normal_dist, normal_dist)","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"note: Note\nBoth r_obs and err_resp have the same type, eg. MTResponse. ","category":"page"},{"location":"probabilistic_inverse.html#Inference","page":"Interface","title":"Inference","text":"","category":"section"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"We now have all the ingredients to perform inversion, except the sampler. This page provides a brief review of samplers Turing.jl provides. The number of posterior points to be sampled n_samples, the algorithm mcmc_alg and the distributions are brought together by mcmc_cache.","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"mcmc_alg = NUTS();\nn_samples = 40;\nmcache = mcmc_cache(modelD, respD, n_samples, mcmc_alg);","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"The posterior samples are then sampled by simply calling:","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"mcmc_chain = stochastic_inverse(r_obs, err_resp, ω, mcache)","category":"page"},{"location":"probabilistic_inverse.html#Copy-Pasteable-code","page":"Interface","title":"Copy-Pasteable code","text":"","category":"section"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"using MT\nusing Distributions\nusing Turing\nusing LinearAlgebra\n\n\nm_test = MTModel(log10.([100., 10., 1000.]), [1e3, 1e3]);\nf = 10 .^ range(-4, stop = 1, length = 25);\nω = vec(2π .* f);\n\nr_obs = forward(m_test, ω);\n\nerr_phi = asin(0.01) * 180/π .* ones(length(ω));\nerr_appres = 0.02 * r_obs.ρₐ;\nerr_resp = MTResponse(err_appres, err_phi);\n\nr_obs.ρₐ .= r_obs.ρₐ .+ err_appres;\nr_obs.ϕ .= r_obs.ϕ .+ err_phi;\n\nrespD = MTResponseDistribution(normal_dist, normal_dist);\n\nz = 10 .^collect(range(1, stop = 4, length = 100));\nh = diff(z);\n\n\nmodelD = MTModelDistribution(\n    Product(\n    [Uniform(-1., 5.) for i in eachindex(z)]\n    ),\n    vec(h)\n);\n\n\nn_samples = 50;\nmcache = mcmc_cache(modelD, respD, 50, NUTS());\n\nmcmc_chain = stochastic_inverse(r_obs, err_resp, ω, mcache)","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"The obtained mcmc_chain contains the distributions that can be saved using JLD2.jl.","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"using JLD2\nJLD2.@save \"file_path.jld2\" mcmc_chains","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"Note: ","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"note: Note\nThe returned chains will be sampled in the distribution specified by modelD. In the presented case, it will have values in -1 5 and we can get the values by 10. ^ value.","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"The list of models can then be obtained from chains using","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"model_list = get_model_list(mcmc_chains, modelD)","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"We can then easily check the fit of the response curves","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"plt_resps = prepare_plot(r_obs, ω, alpha = 0.);\nresp_models = forward(model_list[1], ω);\n\nfor i in 1:(length(model_list) > 50 ? 50 : length(model_list))\n   forward!(resp_models, model_list[i], ω);\n   prepare_plot!(resp_models, ω, alpha = 0.4); \nend\n\nprepare_plot!(r_obs, ω, d_err = err_resp, markersize = 3, color = :orange);\nplot_response(plt_resps)","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"The posterior distribution can then be obtained as:","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"pre_img = pre_image(m_dist, mt_chain);\nkde_img = get_kde_image(pre_img..., false, xscale = :identity, yscale = :identity, yflip = true)","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"We can also obtain the mean and 1 std deviation bounds as:","category":"page"},{"location":"probabilistic_inverse.html","page":"Interface","title":"Interface","text":"mean_std_plt_lin = get_mean_std_image(pre_img..., yscale = :identity)","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Modules = [MT]\nOrder = [:function]","category":"page"},{"location":"api.html#MT.NonlinearAlg-Tuple{}","page":"API","title":"MT.NonlinearAlg","text":"NonlinearAlg(; alg = LevenbergMarquardt, μ = 1.0)\n\nreturns nl_cache that specifies which non linear solver to use for the inverse problem\n\nKeyword Arguments\n\nalg: NonlinearSolve[@ref] algorithm to be used, defaults to LevenbergMarquardt\nμ : regularization weight\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.Occam-Tuple{}","page":"API","title":"MT.Occam","text":"Occam(;μgrid= [0.01, 1e6])\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.OptAlg-Tuple{}","page":"API","title":"MT.OptAlg","text":"OptAlg(; alg = LBFGS, μ = 1.0, kwargs...)\n\nreturns nl_cache that specifies which non linear solver to use for the inverse problem\n\nKeyword Arguments\n\nalg: NonlinearSolve[@ref] algorithm to be used, defaults to LBFGS\nμ : regularization weight\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.construct_mixing_models-NTuple{5, Vector}","page":"API","title":"MT.construct_mixing_models","text":"construct_mixing_models(params, p_names, ϕ, model_list, mixing_type)\n\nreturns a mixing_models type containing all the variables for rock physics modeling\n\nArguments\n\nparams : parameter values for rock physics models\np_names : list of symbols, each associating with each value in params\nϕ : vol fraction of different phases\nfor mixing_type = single_phase, ϕ = [1] (total vol occupied by one phase)\nfor mixing_type = HS1962_plus and HS1962_minus, ϕ is a vector of one element that can be varied but should be less than 1. This is the vol melt fraction.\nmodel_list : list of model types required to build up the rock physics model and mixing them\nmixing_type : determines how to mix model types. Current mixing laws include\nsingle_phase : no mixing, when there's only a single phase\nHS1962_plus : mixing two phases to get the Hashim Strikman upper bound\nHS1962_minus : mixing two phases to get the Hashim Strikman lower bound\nMAL : mixing the two phases using the Modified Archie's Law\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.d_sigmoid-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1, T2}","page":"API","title":"MT.d_sigmoid","text":"d_sigmoid(m): gradient for the transformation from optimization domain to model domain. Used for estimating jacobians, but is also useful in analysing sensitivities.\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.forward!-Union{Tuple{T3}, Tuple{T}, Tuple{Tm}, Tuple{Tr}, Tuple{Tr, Tm, T3}, Tuple{Tr, Tm, T3, T}} where {Tr<:MTResponse, Tm<:MTModel, T, T3}","page":"API","title":"MT.forward!","text":"forward!(r::response, m::model, ω::Vector{T}) where T <: Union{Float32, Float64}:\n\nupdates response r type for the given model m at the frequencies  ω\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.forward-Union{Tuple{T3}, Tuple{T}, Tuple{Tm}, Tuple{Tm, T3}, Tuple{Tm, T3, T}} where {Tm<:MTModel, T, T3}","page":"API","title":"MT.forward","text":"forward(m::model, ω::Vector{T}) where T <: Union{Float32, Float64}:\n\nreturns a  response for the given model m at the frequencies  ω\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.gaussian_kernel","page":"API","title":"MT.gaussian_kernel","text":"gaussian_kernel(u, σ² = 2)\n\nreturn gaussian kernel centered at 0, at points given by u with std deviation of σ\n\n\n\n\n\n","category":"function"},{"location":"api.html#MT.get_appres-Tuple{Any, Any}","page":"API","title":"MT.get_appres","text":"get_appres(Z, ω): returns the ρₐ for impedance\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_kde-Tuple{Any, Any}","page":"API","title":"MT.get_kde","text":"get_kde(data, xgrid; Κ= gaussian_kernel)\n\nreturns distribution of data using kernel density estimation\n\nArguments\n\ndata : 1D vector to evaluate distribution for\nxgrid : 1D vector to evaluate distribution on\n\nKeyword Arguments\n\nΚ : kernel used to evaluate density, defaults to gaussian_kernel[@ref]\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_kde_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C<:MCMCChains.Chains, mdist<:(MTModelDistribution{<:Distributions.Distribution, <:AbstractArray})}","page":"API","title":"MT.get_kde_image!","text":"get_kde_image!(fig,\n    chain::C,\n    mDist::mdist;\n    hm_kwargs=(;),\n    cb_kwargs=(;),\n    K=gaussian_kernel,\n    half_space_depth=nothing,\n    kde_transformation_fn = identity,\n    return_kde_mat=false,\n    trans_utils=(m=lin_tf, h=lin_tf),\n    grid=(m=collect(-1:0.1:5), z=cumsum(mDist.h))) where {\n    C <: Chains, mdist <: MTModelDistribution{<:Distribution, <:AbstractArray}}\n\nplots on fig, a heatmap of probability distributions sampled by a chain using kernel density estimation\n\nArguments\n\nfig : Figure on which the heatmap is plotted\nchain : samples in the form Turing.Chains from an MCMC sampling\nmDist : apriori model distribution used for MCMC sampling\n\nKeyword Arguments\n\nhm_kwargs : NamedTuple containing keyword arguments for customizing heatmap\ncb_kwargs : NamedTuple containing keyword arguments for customizing colorbar\nK : kernel used to perform kernel density estimation\nhalf_space_depth : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to 1.25 × last\nkde_transformation_fn : a function that transforms the image domain, eg., use log10 to plot log pdf; defaults to identity which implies no bounds_transformation\nreturn_kde_mat : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to false\ntrans_utils : NamedTuple containing functions to transform the samples; defaults to no lin_tf for all parameters\ngrid : NamedTuple containing grid to evaluate the kernel density on. m refers to the points to evaluate kde of model parameters, z refers to the depth points at which the model samples are inferred, not used if h is not sampled.\n\nnote: Note\n\n\nAlso check relevant tutorial page!\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_kde_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C<:MCMCChains.Chains, mdist<:(MTModelDistribution{<:Distributions.Distribution, <:Distributions.Distribution})}","page":"API","title":"MT.get_kde_image!","text":"get_kde_image!(fig,\n    chain,\n    mDist;\n    hm_kwargs=(;),\n    cb_kwargs=(;),\n    K=gaussian_kernel,\n    half_space_depth=nothing,\n    kde_transformation_fn = identity,\n    return_kde_mat=false,\n    trans_utils=(m=lin_tf, h=lin_tf),\n    grid=(m=collect(-1:0.1:5), z=cumsum(mDist.h))) where {\n    C <: Chains, mdist <: MTModelDistribution}\n\nplots on fig, a heatmap of probability distributions sampled by a chain using kernel density estimation\n\nArguments\n\nfig : Figure on which the heatmap is plotted\nchain : samples in the form Turing.Chains from an MCMC sampling\nmDist : apriori model distribution used for MCMC sampling\n\nKeyword Arguments\n\nhm_kwargs : NamedTuple containing keyword arguments for customizing heatmap\ncb_kwargs : NamedTuple containing keyword arguments for customizing colorbar\nK : kernel used to perform kernel density estimation\nhalf_space_depth : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to 1.25 × last\nkde_transformation_fn : a function that transforms the image domain, eg., use log10 to plot log pdf; defaults to identity which implies no bounds_transformation\nreturn_kde_mat : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to false\ntrans_utils : NamedTuple containing functions to transform the samples; defaults to no lin_tf for all parameters\ngrid : NamedTuple containing grid to evaluate the kernel density on. m refers to the points to evaluate kde of model parameters, z refers to the depth points at which the model samples are inferred, not used if h is not sampled.\n\nnote: Note\n\n\nAlso check relevant tutorial page!\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_kde_image-Tuple","page":"API","title":"MT.get_kde_image","text":"get_kde_image!(fig,\n    chain,\n    mDist;\n    hm_kwargs=(;),\n    cb_kwargs=(;),\n    K=gaussian_kernel,\n    half_space_depth=nothing,\n    kde_transformation_fn = identity,\n    return_kde_mat=false,\n    trans_utils=(m=lin_tf, h=lin_tf),\n    grid=(m=collect(-1:0.1:5), z=cumsum(mDist.h)))\n\nreturns fig, a heatmap of probability distributions sampled by a chain using kernel density estimation\n\nArguments\n\nfig : Figure on which the heatmap is plotted\nchain : samples in the form Turing.Chains from an MCMC sampling\nmDist : apriori model distribution used for MCMC sampling\n\nKeyword Arguments\n\nhm_kwargs : NamedTuple containing keyword arguments for customizing heatmap\ncb_kwargs : NamedTuple containing keyword arguments for customizing colorbar\nK : kernel used to perform kernel density estimation\nhalf_space_depth : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to 1.25 × last\nkde_transformation_fn : a function that transforms the image domain, eg., use log10 to plot log pdf; defaults to identity which implies no bounds_transformation\nreturn_kde_mat : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to false\ntrans_utils : NamedTuple containing functions to transform the samples; defaults to no lin_tf for all parameters\ngrid : NamedTuple containing grid to evaluate the kernel density on. m refers to the points to evaluate kde of model parameters, z refers to the depth points at which the model samples are inferred, not used if h is not sampled.\n\nnote: Note\n\n\nAlso check relevant tutorial page!\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_mean_std_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, Any, Any}} where {C<:MCMCChains.Chains, mdist<:(MTModelDistribution{<:Distributions.Distribution, <:AbstractArray})}","page":"API","title":"MT.get_mean_std_image!","text":"get_mean_std_image!(ax,\n    chain,\n    mDist::mdist;\n    confidence_interval=0.95,\n    half_space_depth=nothing,\n    plot_kwargs=nothing,\n    trans_utils=(m=lin_tf, h=lin_tf))\n\nplots on ax, a bounds plot (using mean and std deviation) of probability distributions sampled by a chain using kernel density estimation\n\nArguments\n\nfig : Axis on which the probability bounds are plotted\nchain : samples in the form Turing.Chains from an MCMC sampling\nmDist : apriori model distribution used for MCMC sampling\n\nKeyword Arguments\n\nconfidence_interval : a confidence_interval of 0.9 implies 90% of values are within the bounds\nhalf_space_depth : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to 1.25 × last\nplot_kwargs : NamedTuple containing keyword arguments for plots\nreturn_kde_mat : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to false\ntrans_utils : NamedTuple containing functions to transform the samples; defaults to no lin_tf for all parameters\nz_points : depth points at which bounds are plotted, not used if h is not sampled; defaults to depths corresponding to mean(h)\n\nnote: Note\n\n\nAlso check relevant tutorial page!\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_mean_std_image!-Union{Tuple{mdist}, Tuple{C}, Tuple{Any, C, mdist}} where {C<:MCMCChains.Chains, mdist<:(MTModelDistribution{<:Distributions.Distribution, <:Distributions.Distribution})}","page":"API","title":"MT.get_mean_std_image!","text":"get_mean_std_image!(ax,\n    chain,\n    mDist;\n    confidence_interval=0.95,\n    half_space_depth=nothing,\n    plot_kwargs=nothing,\n    trans_utils=(m=lin_tf, h=lin_tf))\n\nplots on ax, a bounds plot (using mean and std deviation) of probability distributions sampled by a chain using kernel density estimation\n\nArguments\n\nfig : Axis on which the probability bounds are plotted\nchain : samples in the form Turing.Chains from an MCMC sampling\nmDist : apriori model distribution used for MCMC sampling\n\nKeyword Arguments\n\nconfidence_interval : a confidence_interval of 0.9 implies 90% of values are within the bounds\nhalf_space_depth : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to 1.25 × last\nplot_kwargs : NamedTuple containing keyword arguments for plots\nreturn_kde_mat : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to false\ntrans_utils : NamedTuple containing functions to transform the samples; defaults to no lin_tf for all parameters\nz_points : depth points at which bounds are plotted, not used if h is not sampled; defaults to depths corresponding to mean(h)\n\nnote: Note\n\n\nAlso check relevant tutorial page!\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_mean_std_image-Tuple","page":"API","title":"MT.get_mean_std_image","text":"get_mean_std_image!(chain,\n    mDist;\n    confidence_interval=0.95,\n    half_space_depth=nothing,\n    plot_kwargs=nothing,\n    trans_utils=(m=lin_tf, h=lin_tf))\n\nreturn fig, a figure with a bounds plot (using mean and std deviation) of probability distributions sampled by a chain using kernel density estimation\n\nArguments\n\nfig : Axis on which the probability bounds are plotted\nchain : samples in the form Turing.Chains from an MCMC sampling\nmDist : apriori model distribution used for MCMC sampling\n\nKeyword Arguments\n\nconfidence_interval : a confidence_interval of 0.9 implies 90% of values are within the bounds\nhalf_space_depth : extent of half space, i.e., the last layer, informs how far to extend the half space, defaults to 1.25 × last\nplot_kwargs : NamedTuple containing keyword arguments for plots\nreturn_kde_mat : whether to return the matrix containing the values of heatmap along with corresponding x,y axes; defaults to false\ntrans_utils : NamedTuple containing functions to transform the samples; defaults to no lin_tf for all parameters\nz_points : depth points at which bounds are plotted, not used if h is not sampled; defaults to depths corresponding to mean(h)\n\nnote: Note\n\n\nAlso check relevant tutorial page!\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_model_list-Union{Tuple{chain}, Tuple{mdist}, Tuple{chain, mdist}} where {mdist<:AbstractModelDistribution, chain<:MCMCChains.Chains}","page":"API","title":"MT.get_model_list","text":"get_model_list(chains::chain, mDist::mdist; \n    trans_utils = (m = pow_tf, h = lin_tf,)) where {mdist <: AbstractModelDistribution, chain <: Chains}\n\nreturns a list of models from the Chains variable obtained from stochastic_inverse\n\nArguments\n\nchains : Chains object obtained from the Turing model\nmDist : a priori distribution defined before performing stochastic inversion\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_phase-Tuple{Any}","page":"API","title":"MT.get_phase","text":"get_phase(Z): returns the phase for impedance\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.get_ρ_at_z-Tuple{Any, Any}","page":"API","title":"MT.get_ρ_at_z","text":"get_ρ_at_z(pred, zs)\n\nreturns the values of the model splatted as a vector in pred at points defined by zs\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.inverse!-Union{Tuple{resp_utils_T}, Tuple{trans_utils_T}, Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, occam_cache}} where {model1<:AbstractGeophyModel, response<:AbstractGeophyResponse, trans_utils_T, resp_utils_T}","page":"API","title":"MT.inverse!","text":"function inverse!(mₖ::model,\n        robs::response,\n        vars::Vector{Float64},\n        alg_cache::occam_cache;\n        W= nothing,\n        L= nothing,\n        max_iters= 30, χ2=1.,\n        response_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(robs))],\n        model_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(m₀))], # this will not be used but for the sake of generality for all inverse algs\n        model_trans_utils::transform_utils= sigmoid_tf,\n        verbose= true\n    ):\n\nupdates mₖ using occam iteration to fit robs within a misfit of χ2, by default set to 1.0\n\nVariables:\n\nmₖ: Initial model guess, will be updated during the inverse process\nrobs: response to invert for\nvars: variables required for forward modeling, eg., ω for MT\nalg_cache: deterimines the algorithm to be performed for inversion\nW: Weight matrix, defaults to identity matrix I\nL: Regularization matrix, defaults to derivative matrix, given by ∂(@ref)\nmax_iters= 30: maximum number of iterations\nχ2=1.: target misfit\n`response_fields: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)\nmodel_trans_utils:transform_utils= pow_sigmoid_tf: conversion to and from computational domain,\nresponse_trans_utils: for scaling the response parameters,\nmᵣ: model in physical domain to be regularized against\nreg_term: (For internals) When model in physical domain does not exist, reg_term helps, eg. case of RTO-TKO\nverbose: whether to print updates after each iteration, defaults to true\n\nReturns:\n\nreturn message in the form of return_code and updates mₖ in-place.\n\nExample:\n\ninverse!(m_occam, r_obs, Occam([1e-2, 1e6]))\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.inverse!-Union{Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, nl_cache}} where {model1<:AbstractGeophyModel, response<:AbstractGeophyResponse}","page":"API","title":"MT.inverse!","text":"function inverse!(mₖ::model1,\n        robs::response,\n        vars::Vector{Float64},\n        alg_cache::nl_cache;\n        W=nothing,\n        L=nothing,\n        max_iters=30,\n        χ2=1.0,\n        response_fields::Vector{Symbol}=[k for k in fieldnames(typeof(robs))],\n        # model_fields::Vector{Symbol}=[k for k in fieldnames(typeof(mₖ))], # this will not be used but for the sake of generality for all inverse algs\n        model_trans_utils::transform_utils=pow_sigmoid_tf,\n        response_trans_utils::transform_utils=log_tf,\n        verbose::Bool=true,\n        mᵣ=nothing) where {\n        model1 <: AbstractGeophyModel, response <: AbstractGeophyResponse}\n\nupdates mₖ using occam iteration to fit robs within a misfit of χ2, by default set to 1.0.\n\nVariables:\n\nmₖ: Initial model guess, will be updated during the inverse process\nrobs: response to invert for\nvars: variables required for forward modeling, eg., ω for MT\nalg_cache::occam_cache: deterimines the algorithm to be performed for inversion\nW: Weight matrix, will be I if nothing is provided\nL: Regularization matrix, defaults to derivative matrix, given by ∂[@ref]\nmax_iters: maximum number of iterations, defaults to 30\nχ2: threshold misfit, defaults to 1.0\nresponse_fields: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)\nmodel_fields: will generally be fixed, see docs for details\nmodel_trans_utils: conversion to and from computational domain,\nresponse_trans_utils: for scaling the response parameters,\nverbose: whether to print updates after each iteration, defaults to true\nmᵣ: model in physical domain to be regularized against\n\nReturns:\n\nreturn message in the form of return_code and updates mₖ in-place.\n\nExample:\n\ninverse!(m_occam, r_obs, ω, NonlinearAlg(; alg = LevenbergMarquardt, μ = 1.0))\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.inverse!-Union{Tuple{response}, Tuple{model1}, Tuple{model1, response, Vector{Float64}, opt_cache}} where {model1<:AbstractGeophyModel, response<:AbstractGeophyResponse}","page":"API","title":"MT.inverse!","text":"function inverse!(mₖ::model1,\n        robs::response,\n        vars::Vector{Float64},\n        alg_cache::opt_cache;\n        W=nothing,\n        L=nothing,\n        max_iters=30,\n        χ2=1.0,\n        response_fields::Vector{Symbol}=[k for k in fieldnames(typeof(robs))],\n        # model_fields::Vector{Symbol}=[k for k in fieldnames(typeof(mₖ))], # this will not be used but for the sake of generality for all inverse algs\n        model_trans_utils::transform_utils=pow_sigmoid_tf,\n        response_trans_utils::transform_utils=log_tf,\n        verbose::Bool=true,\n        mᵣ=nothing) where {\n        model1 <: AbstractGeophyModel, response <: AbstractGeophyResponse}\n\nupdates mₖ using occam iteration to fit robs within a misfit of χ2, by default set to 1.0.\n\nVariables:\n\nmₖ: Initial model guess, will be updated during the inverse process\nrobs: response to invert for\nvars: variables required for forward modeling, eg., ω for MT\nalg_cache::occam_cache: deterimines the algorithm to be performed for inversion\nW: Weight matrix, will be I if nothing is provided\nL: Regularization matrix, defaults to derivative matrix, given by ∂[@ref]\nmax_iters: maximum number of iterations, defaults to 30\nχ2: threshold misfit, defaults to 1.0\nresponse_fields: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)\nmodel_fields: will generally be fixed, see docs for details\nmodel_trans_utils: conversion to and from computational domain,\nresponse_trans_utils: for scaling the response parameters,\nverbose: whether to print updates after each iteration, defaults to true\nmᵣ: model in physical domain to be regularized against\n\nReturns:\n\nreturn message in the form of return_code and updates mₖ in-place.\n\nExample:\n\ninverse!(m_occam, r_obs, ω, NonlinearAlg(; alg = LBFGS, μ = 1.0))\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.inverse_sigmoid-Union{Tuple{T1}, Tuple{T}, Tuple{T1, Vector{T}}} where {T<:Union{Float32, Float64}, T1}","page":"API","title":"MT.inverse_sigmoid","text":"inverse_sigmoid(): get back to the optimization domain from model domain\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.linsolve!-NTuple{4, Any}","page":"API","title":"MT.linsolve!","text":"linsolve!: Performs inv(B)*y using LinearSolve.jl\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.mcmc_turing-Union{Tuple{rdist}, Tuple{mdist}, Tuple{response}, Tuple{model}, Tuple{model, Any, Any, NamedTuple, response, mdist, rdist}} where {model<:AbstractModel, response<:AbstractResponse, mdist<:AbstractModelDistribution, rdist<:AbstractResponseDistribution}","page":"API","title":"MT.mcmc_turing","text":"@model function mcmc_turing(\n    m_sample::model,\n    vars,\n    r_obs::NamedTuple,\n    err_resp::MTResponse,\n    mDist::mdist,\n    rDist::rdist;\n    response_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(rDist))],\n    model_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(mDist))],\n    trans_utils::NamedTuple = (m = log_tf, h = lin_tf)\n    ) where {model <: AbstractModel, mdist <: AbstractModelDistribution, rdist <: AbstractResponseDistribution}\n\nmakes a Turing.jl model to perform MCMC sampling\n\nVariables:\n\nvars: variables that need to be passed into the forward function along with model to generate a response\nr_obs: named tuple containing the observed data, with the same keys as the fields in the corresponding response\nerr_resp: response variable that contains the errors\nmDist: any subtype of AbstractModelDistribution contains the apriori information\nrDist: any subtype of AbstractResponseDistribution contains the likelihood information\n\nKeyword/optional arguments\n\nresponse_fields:  which fields in response to invert for\nmodel_fields: fields in model to draw inference on\ntrans_utils: to transform the model field variables to and from computational (inference) domain\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.normal_dist-Tuple{AbstractVector, AbstractVector}","page":"API","title":"MT.normal_dist","text":"normal_dist(resp::AbstractVector, err_resp::AbstractVector): returns a multivariate normal distribution centered around resp with std dev err_resp\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.occam_step!-Union{Tuple{response}, Tuple{model2}, Tuple{model1}, Tuple{model1, response, Union{AbstractVector{Float32}, AbstractVector{Float64}}, Union{Float32, Float64}, Vector{Float64}, linear_utils, inverse_utils, transform_utils, NamedTuple, LinearSolve.LinearCache}} where {model1<:AbstractGeophyModel, model2<:Union{Nothing, AbstractGeophyModel}, response<:AbstractGeophyResponse}","page":"API","title":"MT.occam_step!","text":"function occam_step!(mₖ₊₁::model,\n    respₖ₊₁::response,\n    vars::Union{AbstractVector{Float32}, AbstractVector{Float64}},\n    χ2::Union{Float64, Float32},\n    μgrid::Vector{Float64},\n    lin_utils::linear_utils,\n    inv_utils::inverse_utils,\n    model_trans_utils::transform_utils,\n    response_trans_utils::NamedTuple,\n    linsolve_prob::LinearSolve.LinearCache;\n    model_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(mₖ₊₁))],\n    response_fields::Vector{Symbol}= [k for k ∈ fieldnames(typeof(respₖ₊₁))],\n    verbose= false\n    ):\n\nperforms a single step of occam inversion, using golden line search.\n\nVariables:\n\nmₖ: Initial model guess, will be updated during the inverse process\nrobs: response to invert for\nvars: variables required for forward modeling, eg., ω for MT\nalg_cache: deterimines the algorithm to be performed for inversion\nW: Weight matrix, defaults to identity matrix I\nL: Regularization matrix, defaults to discretized derivative matrix given by ∂(@ref)\nmax_iters: maximum number of iterations, defaults to 30\nχ2: target misfit, defaults to 1.0\n`response_fields: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)\nmodel_trans_utils: conversion to and from computational domain,\nresponse_trans_utils: NamedTuple containing transform_utils for scaling different response parameters,\nmᵣ: model in physical domain to be regularized against\nreg_term: (For internals) When model in physical domain does not exist, reg_term helps, eg. case of RTO-TKO\nverbose: whether to print updates after each iteration, defaults to true\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.stochastic_inverse-Union{Tuple{resp2}, Tuple{resp1}, Tuple{resp1, resp2, Any, mcmc_cache}} where {resp1<:AbstractResponse, resp2<:AbstractResponse}","page":"API","title":"MT.stochastic_inverse","text":"stochastic_inverse(\n    r_obs::response,\n    err_resp::response,\n    vars,\n    alg_cache::mcmc_cache;\n    model_trans_utils::NamedTuple = (m = lin_tf, h = lin_tf)\n    )\n\nfunction to perform sampling\n\nReturns\n\n`AbstractMCMC.jl Chain` containing the vectors used for performing samping. Note that all the variables will be named `var_inf`, for variable inferred. \nThe vector in each sample will be all the fields of the model being inferred on concatenated together.\n\nVariables\n\nr_obs: response that needs to inverted for\nerr_resp: response variable containing the errors associated with observed response\nvars: variables that need to be passed into the forward function along with model to generate a response\nalg_cache: to tell the compiler what type of stochastic inversion method is to be used\nmodel_trans_utils: A named tuple containing transform_utils for the fields of model that need to be scaled/modified. If not provided for any model field, the field won't be modified.\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.stochastic_inverse-Union{Tuple{resp2}, Tuple{resp1}, Tuple{resp1, resp2, Any, rto_cache}} where {resp1<:AbstractGeophyResponse, resp2<:AbstractGeophyResponse}","page":"API","title":"MT.stochastic_inverse","text":"stochastic_inverse(r_obs::resp1,\n        err_resp::resp2,\n        vars,\n        alg_cache::rto_cache;\n        model_trans_utils::NamedTuple=(m=sigmoid_tf, h=lin_tf),\n        response_trans_utils::NamedTuple=(ρₐ=lin_tf, ϕ=lin_tf)) where {\n        resp1 <: AbstractGeophyResponse, resp2 <: AbstractGeophyResponse}\n\nReturns\n\n`AbstractMCMC.jl Chain` containing the vectors used for performing samping. Note that all the variables will be named `var_inf`, for variable inferred. \nThe vector in each sample will be all the fields of the model being inferred on concatenated together.\n\nArguments\n\nr_obs: response that needs to inverted for\nerr_resp: response variable containing the errors associated with observed response\nvars: variables that need to be passed into the forward function along with model to generate a response\nalg_cache: to tell the compiler what type of stochastic inversion method is to be used\n\nKeyword Arguments\n\nmodel_trans_utils: A named tuple containing transform_utils for the fields of model that need to be scaled/modified. If not provided for any model field, the field won't be modified\nresponse_trans_utils: for scaling the response parameters\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.uniform_dist-Tuple{AbstractVector, AbstractVector}","page":"API","title":"MT.uniform_dist","text":"uniform_dist(resp::AbstractVector, err_resp::AbstractVector): returns a uniform normal distribution ∈ [resp-err_resp/2, resp+err_resp/2]\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.χ²-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1, T2}","page":"API","title":"MT.χ²","text":"χ²(dcal::T, dobs::T; W): returns a chi-squared error between the observed and the calculated data. W can optionally be passed to weigh points differently.\n\n\n\n\n\n","category":"method"},{"location":"api.html#MT.∂-Tuple{Any}","page":"API","title":"MT.∂","text":"∂(n): returns a nxn matrix for a 1D finite difference stencil using 2 points.\n\n\n\n\n\n","category":"method"},{"location":"api.html","page":"API","title":"API","text":"Modules = [MT]\nOrder = [:type]","category":"page"},{"location":"api.html#MT.AbstractGeophyModel","page":"API","title":"MT.AbstractGeophyModel","text":"Abstract model type that is the supertype of all geophysical models in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractGeophyModelDistribution","page":"API","title":"MT.AbstractGeophyModelDistribution","text":"Abstract model type that is the supertype of all geophysical model distributions in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractGeophyResponse","page":"API","title":"MT.AbstractGeophyResponse","text":"Abstract model type that is the supertype of all geophysical responses in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractGeophyResponseDistribution","page":"API","title":"MT.AbstractGeophyResponseDistribution","text":"Abstract model type that is the supertype of all geophysical response distributions in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractModel","page":"API","title":"MT.AbstractModel","text":"Abstract model type that is the supertype of all models in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractModelDistribution","page":"API","title":"MT.AbstractModelDistribution","text":"Abstract model type that is the supertype of all model distributions in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractResponse","page":"API","title":"MT.AbstractResponse","text":"Abstract model type that is the supertype of all responses in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractResponseDistribution","page":"API","title":"MT.AbstractResponseDistribution","text":"Abstract model type that is the supertype of all response distributions in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractRockphyModel","page":"API","title":"MT.AbstractRockphyModel","text":"Abstract model type that is the supertype of all rock models in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractRockphyModelDistribution","page":"API","title":"MT.AbstractRockphyModelDistribution","text":"Abstract model type that is the supertype of all rock physics model distributions in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractRockphyResponse","page":"API","title":"MT.AbstractRockphyResponse","text":"Abstract model type that is the supertype of all rock physics responses in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.AbstractRockphyResponseDistribution","page":"API","title":"MT.AbstractRockphyResponseDistribution","text":"Abstract model type that is the supertype of all rock physics response distributions in the package.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.Gaillard2008","page":"API","title":"MT.Gaillard2008","text":"Gaillard2008(T)\n\nElectrical conductivity model for melt dependent on Temperature. For further reading look at the references below.\n\nUsage\n\njulia> model = Gaillard2008(1000 + 273.)\n\njulia> log_cond = forward(model, [])\n\nArguments\n\nT : Temperature of melt (should be greater than 1146.8 K)\n\nReferences\n\nGaillard, Fabrice & Malki, Mohammed & Iacono-Marziano, Giada & Pichavant, Michel & Scaillet, Bruno. (2008), \"Carbonatite Melts and Electrical Conductivity in the Asthenosphere\", Science (New York, N.Y.). 322. 1363-5, doi: 10.1126/science.1164446.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.HS1962_minus","page":"API","title":"MT.HS1962_minus","text":"HS1962_minus\n\nHashim-Strikman lower bound for mixing 2 phases\n\nUsage\n\njulia> model_mix = construct_mixing_models([1000. + 273., 2e4],\n    [:T, :Ch2o_m],\n    [0.1],\n    [SEO3, Ni2011],\n    [HS1962_minus()]\n)\njulia> log_cond = forward(model_mix, [])\n\nReferences\n\nPaul W. J. Glover (2010), \"A generalized Archie's law for n phases\", Geophysics 2010; 75 (6): E247–E265, doi: https://doi.org/10.1190/1.3509781\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.HS1962_plus","page":"API","title":"MT.HS1962_plus","text":"HS1962_plus\n\nHashim-Strikman upper bound for mixing 2 phases\n\nUsage\n\njulia> model_mix = construct_mixing_models([1000. + 273., 2e4]\n    [:T, :Ch2o_m]],\n    Product([Uniform(0., 1.)]),\n    [SEO3, Ni2011],\n    [HS1962_minus()]\n)\njulia> log_cond = forward(model_mix, [])\n\nReferences\n\nPaul W. J. Glover (2010), \"A generalized Archie's law for n phases\", Geophysics 2010; 75 (6): E247–E265. doi: https://doi.org/10.1190/1.3509781\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.Jones2012","page":"API","title":"MT.Jones2012","text":"Jones2012(T, Ch2o_ol)\n\nElectrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.\n\nArguments\n\nT : Temperature of olivine (in K)\nCh2o_ol : water concentration in olivine (in ppm)\n\nUsage\n\njulia> model = Jones2012(1000 + 273., 2e4)\n\njulia> log_cond = forward(model, [])\n\nReferences\n\nJones, A. G., J. Fullea, R. L. Evans, and M. R. Muller (2012), \"Water in cratonic lithosphere: Calibrating laboratory-determined models of electrical conductivity of mantle minerals using geophysical and petrological observations\", Geochem. Geophys. Geosyst., 13, Q06010, doi:10.1029/2012GC004055.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.MAL","page":"API","title":"MT.MAL","text":"MAL\n\nModified Archie's law for mixing 2 phases\n\nUsage\n\njulia> model_mix = construct_mixing_models([1000. + 273., 2e4]\n    [:T, :Ch2o_m]],\n    Product([Uniform(0., 1.)]),\n    [SEO3, Ni2011],\n    [MAL(1.2)]\n)\njulia> log_cond = forward(model_mix, [])\n\nReferences\n\nGlover, P. W. J., Hole, M. J., & Pous, J. (2000), \"A Modified Archie’s Law for two conducting phases\", Earth and Planetary Science Letters, 180(3–4), 369–383, doi: https://doi.org/10.1016/S0012-821X(00)00168-0\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.MTModel","page":"API","title":"MT.MTModel","text":"create a model type for a given resistivity distribution that can be used to calculate forward response for 1d MT\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.MTModelDistribution","page":"API","title":"MT.MTModelDistribution","text":"mutable struct modelDistribution{T1<: Union{Distribution, AbstractArray}, T2<: Union{Distribution, AbstractArray}} # where T1,T2 \n    m::T1\n    h::T2\nend\n\ncreate a placeholder to store the Distributions.jl sampler for a priori\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.MTResponseDistribution","page":"API","title":"MT.MTResponseDistribution","text":"struct responseDistribution{T1<: Union{Function, Nothing}, T2<: Union{Function, Nothing}} # where T1,T2\n    ρₐ::T1\n    ϕ::T2\nend\n\ncreate a placeholder to store functions to obtain Distributions.jl samplers for the likelihood function\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.Ni2011","page":"API","title":"MT.Ni2011","text":"Ni2011(T, Ch2o_m)\n\nElectrical conductivity model for basaltic melt dependent on Temperature and water content in melt. For further reading look at the references below.\n\nArguments\n\nT : Temperature of melt (should be greater than 1146.8 K)\nCh2o_m : water concentration in melt (in ppm)\n\nUsage\n\njulia> model = Ni2011(1000 + 273., 2e4)\n\njulia> log_cond = forward(model, [])\n\nReferences\n\nNi, H., Keppler, H. & Behrens, H. (2011), \"Electrical conductivity of hydrous basaltic melts: implications for partial melting in the upper mantle.\", Contrib Mineral Petrol 162, 637–650 (2011), doi: https://doi.org/10.1007/s00410-011-0617-4\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.Poe2010","page":"API","title":"MT.Poe2010","text":"Poe2010(T, Ch2o_ol)\n\nElectrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.\n\nArguments\n\nT : Temperature of olivine (in K)\nCh2o_ol : water concentration in olivine (in ppm)\n\nUsage\n\njulia> model = Poe2010(1000 + 273., 2e4)\n\njulia> log_cond = forward(model, [])\n\nReferences\n\nBrent T. Poe, Claudia Romano, Fabrizio Nestola, Joseph R. Smyth (2010), \"Electrical conductivity anisotropy of dry and hydrous olivine at 8GPa\", Physics of the Earth and Planetary Interiors,Volume 181, Issues 3–4, 2010, Pages 103-111, ISSN 0031-9201, https://doi.org/10.1016/j.pepi.2010.05.003.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.RockphyModelDistribution","page":"API","title":"MT.RockphyModelDistribution","text":"RockphyModelDistribution{\n    T1 <: Union{Distribution, AbstractArray}, T2 <: Union{Distribution, AbstractArray}} <:\n            AbstractRockphyModelDistribution\n    params::T1 # vector of parameters \n    p_names::Vector{<:Symbol} # Vector of symbols telling the parameters in vector \n    ϕ::T2 # phase ratios\n    model_list::Vector{<:Type}\n    mixing_type::Vector\n\nInitializes a placeholder for all the variables to be initialized for use in the stochastic_inverse(@ref stochasticinverse). Has the same structure as `constructmixingmodels`(@ref constructmixing_models) but instead inputs distributions, and therefore respects the same form.\n\nArguments\n\nparams : A distribution from Distributions.jl to sample the rock physics parameters.\np_names : The params vector contains the distributions for the parameters specified by the vector of symbols called p_names\nϕ : Vol. fraction of different phases (can be a distribution or a vector)\nmodel_list : list of models to be used in mixing\nmixing_type : Type of mixing model to be used\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.SEO3","page":"API","title":"MT.SEO3","text":"SEO3(T)\n\nElectrical conductivity model for olivine dependent on temperature. \n\nFor further reading look at the references below.\n\nArguments\n\n- `T` : Temperature of olivine (in K)\n\nUsage\n\njulia> model = SEO3(1000 + 273.)\n\njulia> log_cond = forward(model, [])\n\nReferences\n\nConstable, S (2006), \"SEO3: A new model of olivine electrical conductivity\", Geophysical Journal International, Volume 166, Issue 1, July 2006, Pages 435–437, https://doi.org/10.1111/j.1365-246X.2006.03041.x\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.Sifre2014","page":"API","title":"MT.Sifre2014","text":"Sifre2014(T, Ch2o_m, Cco2_m)\n\nElectrical conductivity model for melt dependent on Temperature, water content and CO₂ content in melt. For further reading look at the references below.\n\nArguments\n\nT : Temperature of melt (should be greater than 1146.8 K)\nCh2o_m : water concentration in melt (in ppm)\nCco2_m : Co2 concentration in melt (in ppm)\n\nUsage\n\njulia> model = Sifre2014(1000 + 273., 2e4, 2e4)\n\njulia> log_cond = forward(model, [])\n\nReferences\n\nSifré, D., Gardés, E., Massuyeau, M. et al. (2014), \"Electrical conductivity during incipient melting in the oceanic low-velocity zone.\" Nature 509, 81–85 (2014), doi: https://doi.org/10.1038/nature13245\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.UHO2014","page":"API","title":"MT.UHO2014","text":"UHO2014(T, Ch2o_ol)\n\nElectrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.\n\nArguments\n\nT : Temperature of olivine (in K)\nCh2o_ol : water concentration in olivine (in ppm)\n\nReferences\n\nGardés, E., F. Gaillard, and P. Tarits (2014), \"Toward a unified hydrous olivine electrical conductivity law\", Geochem. Geophys. Geosyst., 15, 4984–5000, doi:10.1002/2014GC005496.\n\nUsage\n\njulia> model = UHO2014(1000 + 273., 2e4)\n\njulia> log_cond = forward(model, [])\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.Wang2006","page":"API","title":"MT.Wang2006","text":"Wang2006(T, Ch2o_ol)\n\nElectrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.\n\nArguments\n\nT : Temperature of olivine (in K)\nCh2o_ol : water concentration in olivine (in ppm)\n\nUsage\n\njulia> model = Wang2006(1000 + 273., 2e4)\n\njulia> log_cond = forward(model, [])\n\nReferences\n\nWang, D., Mookherjee, M., Xu, Y. et al. (2006), \"The effect of water on the electrical conductivity of olivine\", Nature 443, 977–980 (2006), doi: https://doi.org/10.1038/nature05256\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.Yoshino2009","page":"API","title":"MT.Yoshino2009","text":"Yoshino2009(T, Ch2o_ol)\n\nElectrical conductivity model for olivine dependent on temperature and water concentration. For further reading look at the references below.\n\nArguments\n\nT : Temperature of olivine (in K)\nCh2o_ol : water concentration in olivine (in ppm)\n\nUsage\n\njulia> model = Yoshino2009(1000 + 273., 2e4)\n\njulia> log_cond = forward(model, [])\n\nReferences\n\nTakashi Yoshino, Takuya Matsuzaki, Anton Shatskiy, Tomoo Katsura (2009), \"The effect of water on the electrical conductivity of olivine aggregates and its implications for the electrical structure of the upper mantle, Earth and Planetary Science Letters\", Volume 288, Issues 1–2, 2009, Pages 291-300, ISSN 0012-821X, https://doi.org/10.1016/j.epsl.2009.09.032.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.const_matrix","page":"API","title":"MT.const_matrix","text":"const_matrix(σ)\n\nFixed electrical conductivity model for the phase.\n\nArguments\n\nσ : Conductivity of the phase\n\nUsage\n\njulia> model = const_matrix(1000.)\n\njulia> log_cond = forward(model, [])\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.inverse_utils","page":"API","title":"MT.inverse_utils","text":"struct inverse_utils: contains the utilities for inversion, once initialized, will not be updated in the inversion iterations D: second derivative operator, W: weight matrix, dobs: data response to be inverted for.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.linear_utils","page":"API","title":"MT.linear_utils","text":"struct linear_utils: contains the utilities for linearizing the forward model => mₖ:model, Fₖ: Forward response at mₖ, Jₖ: Jacobian at mₖ.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.mcmc_cache","page":"API","title":"MT.mcmc_cache","text":"mutable struct struct mcmc_cache{T1 <: AbstractGeophyModelDistribution, T2 <: AbstractGeophyResponseDistribution}\n    apriori::T1\n    likelihood::T2\n    n_samples::Int\n    sampler\nend\n\nplaceholder to store\n\napriori in the form of any subtype of AbstractModelDistribution\nlikelihood in the form of any subtype of AbstractResponseDistribution\nnumber of samples to obtain in n_samples\nTuring.jl sampler to be used in sampler\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.mixing_models","page":"API","title":"MT.mixing_models","text":"mixing_models\n\nconstructs a mixing_models type which can then be used to do rock physics modeling. Should be called using construct_mixing_models\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.nl_cache","page":"API","title":"MT.nl_cache","text":"nl_cache: specifies the inverse algorithm while having a cache.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.occam_cache","page":"API","title":"MT.occam_cache","text":"occam_cache: specifies the inverse algorithm while having a cache.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.opt_cache","page":"API","title":"MT.opt_cache","text":"nl_cache: specifies the inverse algorithm while having a cache.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.return_code","page":"API","title":"MT.return_code","text":"struct return_code: contains the information if the inversion was successful\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.rto_cache","page":"API","title":"MT.rto_cache","text":"rto_cache(m₀, μgrid, alg, max_iters, n_samples, χ2, response_fields, L, verbose)\n\nreturns rto_cache that specifies the algorithm to be used for stochastic inversion using RTO-TKO\n\nArguments\n\nm₀: model, usually a starting value to start inversion but mostly to allocate memory space\nμgrid: prior space of μ\nalg: type of algorithm for optimization step, choices include (occam_cache)[@ref], (nl_cache)[@ref], and (opt_cache)[@ref]\nmax_iters: maximum iterations for the optimization scheme\nn_samples: number of samples to be obtained. Note: If there are any spurious samples (say NaN values), they will be automatically deleted, reducing the sample size\nχ2: target misfit\nresponse_fields: choose data of response to perform inversion on, eg., ρₐ for MT, by default chooses all the data (ρₐ and ϕ)\nL: Regularization matrix, defaults to discretized derivative matrix given by ∂(@ref)\nverbose: to print results or not\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.single_phase","page":"API","title":"MT.single_phase","text":"single_phase\n\nSingle phase only conductivity. Assumes the rock matrix is composed of a single phase only.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MT.transform_utils-Union{Tuple{T}, Tuple{Vector{T}, Function, Function, Function}} where T<:Union{Float32, Float64}","page":"API","title":"MT.transform_utils","text":"transform_utils: Contains the parameters and functions for transformation from optimization to model domains.\n\n\n\n\n\n","category":"method"},{"location":"deterministic_inverse.html#Deterministic-Inversion","page":"Deterministic Inverse","title":"Deterministic Inversion","text":"","category":"section"},{"location":"deterministic_inverse.html#Brief-introduction","page":"Deterministic Inverse","title":"Brief introduction","text":"","category":"section"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"Inverse problems in geophysics are notoriously ill-posed with non-unique solutions. MT inversion is no different. Below we demonstrate how we can perform different non-linear inverse schemes on a synthetic dataset.","category":"page"},{"location":"deterministic_inverse.html#Demo","page":"Deterministic Inverse","title":"Demo","text":"","category":"section"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"We start with defining models:","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"using MT, LinearAlgebra, CairoMakie\n\nρ= log10.([100., 10., 400., 1000.])\nh= [100., 1000., 10000.]\nm= MTModel(ρ, h)\n\nT= 10 .^(range(-1,5,length= 19))\nω= 2π./T\n\nf, ax = plot_model(m)\nax.xscale = log10\nax.yscale = log10\nf","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"and getting data, with a 10% error floor.","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"resp= forward(m, ω)\n\nerr_resp = MTResponse(\n    0.1 .* resp.ρₐ,\n    180/π .* asin(0.1) .+ zero(ω)\n    )\n\nf, axs = plot_response(ω, resp, label= \"observed\", plt_type = :scatter)\nplot_response!(axs, ω, resp, errs = err_resp, label= \"observed\", plt_type = :errors, whiskerwidth = 10)\nf","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"It's time to perform a few inversion schemes. All the inversion schemes can be called by the same function call, with just the difference of making an alg_cache, which mostly just depends on the library to be called for the non-linear inverse problem.","category":"page"},{"location":"deterministic_inverse.html#Occam","page":"Deterministic Inverse","title":"Occam","text":"","category":"section"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"Performing occam essentially boils down to making an occam_cache, which is done by making a call to Occam.","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"W = diagm(inv.([err_resp.ρₐ..., err_resp.ϕ...])) .^ 2; # weight matrix\n\nh_test= 10 .^range(0., 5., length= 50)\nρ_test= 2 .*ones(length(h_test)+1)\n\nm_occam= MTModel(ρ_test, h_test);\n\nalg_cache = Occam(; μgrid=[1e-2, 1e6])\ninverse!(m_occam, resp, ω, alg_cache, W = W; max_iters= 50, verbose = true)","category":"page"},{"location":"deterministic_inverse.html#Levenberg-Marquadt","page":"Deterministic Inverse","title":"Levenberg-Marquadt","text":"","category":"section"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"While Occam is implemented in the package, we borrow a few from other packages. One of them is NonlinearSolve.jl, where we have Levenberg-Marquadt scheme. Again, everything boils down to creating the alg_cache. You can use other solvers from the package as well.","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"using NonlinearSolve\n\nh_test= 10 .^range(0., 5., length= 50)\nρ_test= 2. .*ones(length(h_test)+1)\n\nresp_trans_utils = (ρₐ=MT.log_tf, ϕ=MT.phi_scale_tf);\n\nresp_lm = MTResponse(\n    resp_trans_utils[:ρₐ].tf.(resp.ρₐ),\n    resp_trans_utils[:ϕ].tf.(resp.ϕ),\n)\n\nerr_resp_lm = MTResponse(\n    resp_trans_utils[:ρₐ].dtf.(resp.ρₐ) .* err_resp.ρₐ,\n    resp_trans_utils[:ϕ].dtf.(resp.ϕ) .* err_resp.ϕ,\n)\n\nm_lm= MTModel(ρ_test, h_test);\n\nW_lm = diagm(inv.([err_resp_lm.ρₐ..., err_resp_lm.ϕ...])) .^ 2; # weight matrix\n\nalg_cache =  NonlinearAlg(; alg = TrustRegion, μ = 1.0)\ninverse!(m_lm, resp, ω, alg_cache; W =W_lm, max_iters= 20, verbose = true, response_trans_utils = (ρₐ=MT.log_tf, ϕ=MT.phi_scale_tf))","category":"page"},{"location":"deterministic_inverse.html#LBFGS","page":"Deterministic Inverse","title":"LBFGS","text":"","category":"section"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"Another popular algorithm is LBFGS, which we borrow from Optimization.jl. Again, create the alg_cache and it's good to go. Optimization.jl provides a suite of solvers, also by wrapping around a few others.","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"using Optimization, OptimizationOptimJL\n\nh_test= 10 .^range(0., 5., length= 50)\nρ_test= m_occam.m .+ 1 .* randn(length(h_test) + 1)\n\nresp_trans_utils = (ρₐ=MT.log_tf, ϕ=MT.phi_scale_tf);\n\nresp_lbfgs = MTResponse(\n    resp_trans_utils[:ρₐ].tf.(resp.ρₐ),\n    resp_trans_utils[:ϕ].tf.(resp.ϕ),\n)\n\nerr_resp_lbfgs = MTResponse(\n    resp_trans_utils[:ρₐ].dtf.(resp.ρₐ) .* err_resp.ρₐ,\n    resp_trans_utils[:ϕ].dtf.(resp.ϕ) .* err_resp.ϕ,\n)\n\nm_lbfgs= MTModel(ρ_test, h_test);\n\nW_lbfgs = diagm(inv.([err_resp_lbfgs.ρₐ..., err_resp_lbfgs.ϕ...])) .^ 2; # weight matrix\n\nalg_cache =  OptAlg(; alg = LBFGS, μ = 1.0)\ninverse!(m_lbfgs, resp, ω, alg_cache, W = W_lbfgs; max_iters= 50, verbose = true, response_trans_utils = (ρₐ=MT.log_tf, ϕ=MT.phi_scale_tf))","category":"page"},{"location":"deterministic_inverse.html#Fits","page":"Deterministic Inverse","title":"Fits","text":"","category":"section"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"So how well do we fit the data? Note that, in no way we compare the different inversion schemes here. A lot of these schemes depend heavily on the initial model and our choice might be sub-optimal.","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"resp_occam= forward(m_occam, ω);\nresp_lm= forward(m_lm, ω);\nresp_lbfgs= forward(m_lbfgs, ω);\n\nf, axs = plot_response(ω, resp, errs = err_resp, plt_type = :errors, whiskerwidth= 10,)\nplot_response!(axs, ω, resp, plt_type = :scatter, label= \"true\")\nplot_response!(axs, ω, resp_occam, label= \"occam\", plt_type = :plot, color = :magenta)\nplot_response!(axs, ω, resp_lm, label= \"Levenberg-Marquadt\", plt_type = :plot, linewidth= 2)\nplot_response!(axs, ω, resp_lbfgs, label= \"LBFGS\", plt_type = :plot, linewidth= 2)\n\nf[2,2] = Legend(f, axs[1])\nf","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"And a look at different models","category":"page"},{"location":"deterministic_inverse.html","page":"Deterministic Inverse","title":"Deterministic Inverse","text":"f, ax = plot_model(m, label = \"true\", linewidth = 3, color = \"black\")\nplot_model!(ax, m_occam, label = \"occam\", linewidth = 2, color = \"blue\")\nplot_model!(ax, m_lm, label = \"Levenberg-Marquadt\", linewidth = 2)\nplot_model!(ax, m_lbfgs, label = \"LBFGS\", linewidth = 2)\n\n# axislegend(ax, position = :rb)\nax.xscale = log10\nax.yscale = log10\n\nf[1,2] = Legend(f, axs[1])\nf","category":"page"},{"location":"model.html#Model","page":"model","title":"Model","text":"","category":"section"},{"location":"model.html#Demo","page":"model","title":"Demo","text":"","category":"section"},{"location":"model.html","page":"model","title":"model","text":"Specifying a model is easy. Let's say you want to add a resistivity distribution with 4 layers as:","category":"page"},{"location":"model.html","page":"model","title":"model","text":"Layer 1: 500 Omega m, thickness= 100 m\nLayer 2: 1000 Omega m, thickness= 500 m\nLayer 3: 10 Omega m, thickness= 3000 m\nLayer 4: 100 Omega m, half-space","category":"page"},{"location":"model.html","page":"model","title":"model","text":"Define the model using model and you are done.","category":"page"},{"location":"model.html","page":"model","title":"model","text":"using MT\nρ= log10.([500., 100., 400., 1000.]);\nh= [100., 100., 100.];\nm= MTModel(ρ, h)","category":"page"},{"location":"model.html","page":"model","title":"model","text":"This model can then just be passed into forward function to get the response.","category":"page"},{"location":"model.html","page":"model","title":"model","text":"note: Note\nAlways use Float64 or Float32 types while defining the vectors for resistivities and thickness. This is done for performance while not imposing any serious constraints since most of the data is generally processed using Float64 on most CPUs and Float32 on most GPUs.","category":"page"},{"location":"model.html","page":"model","title":"model","text":"The model can then be plotted using ","category":"page"},{"location":"model.html","page":"model","title":"model","text":"f, ax = plot_model(m)\nf","category":"page"},{"location":"tutorials/fixed_discretization.html#Fixed-discretization","page":"MCMC with fixed discretization","title":"Fixed discretization","text":"","category":"section"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"Geophysical models generally have fixed discretization. This is mostly because the different numerical schemes such as finite difference and finite element are computationally expensive and allocating a grid prior to solving the corresponding PDEs saves some computational resources. We provide the capability to do MCMC inference on such fixed grids.","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"Let's denote the model parameters, eg., conductivity, by m, and the layer thickness by h. Therefore, in a N-layer case, we will have ","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"m = m_1 m_2 m_3   m_N \nh = h_1 h_2 h_3   h_N_1","category":"page"},{"location":"tutorials/fixed_discretization.html#Copy-Pasteable-code","page":"MCMC with fixed discretization","title":"Copy-Pasteable code","text":"","category":"section"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"using MT\nusing Distributions\nusing Turing\nusing LinearAlgebra\n\n\nm_test = MTModel(log10.([100., 10., 1000.]), [1e3, 1e3]);\nf = 10 .^ range(-4, stop = 1, length = 25);\nω = vec(2π .* f);\n\nr_obs = forward(m_test, ω);\n\nerr_phi = asin(0.01) * 180/π .* ones(length(ω));\nerr_appres = 0.02 * r_obs.ρₐ;\nerr_resp = MTResponse(err_appres, err_phi);\n\nr_obs.ρₐ .= r_obs.ρₐ .+ err_appres;\nr_obs.ϕ .= r_obs.ϕ .+ err_phi;\n\nrespD = MTResponseDistribution(normal_dist, normal_dist);\n\nz = 10 .^collect(range(1, stop = 4, length = 100));\nh = diff(z);\n\n# fixed discretization\nmodelD = MTModelDistribution(\n    Product(\n    [Uniform(-1., 5.) for i in eachindex(z)]\n    ),\n    vec(h)\n);\n\n\nn_samples = 50;\nmcache = mcmc_cache(modelD, respD, 50, NUTS());\n\nmt_chain = stochastic_inverse(r_obs, err_resp, ω, mcache)","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"The obtained mt_chain contains the distributions that can be saved using JLD2.jl.","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"using JLD2\nJLD2.@save \"file_path.jld2\" mt_chain","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"Note: ","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"note: Note\nThe returned chains will be sampled in the distribution specified by modelD. In the presented case, it will have values in -1 5 and we can get the values by 10. ^ value.","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"The list of models can then be obtained from chains using","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"model_list = get_model_list(mt_chain, modelD)","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"We can then easily check the fit of the response curves","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"plt_resps = prepare_plot(r_obs, ω, alpha = 0.);\nresp_models = forward(model_list[1], ω);\n\nfor i in 1:(length(model_list) > 50 ? 50 : length(model_list))\n   forward!(resp_models, model_list[i], ω);\n   prepare_plot!(resp_models, ω, alpha = 0.4); \nend\n\nprepare_plot!(r_obs, ω, d_err = err_resp, markersize = 3, color = :orange);\nplot_response(plt_resps)","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"The posterior distribution can then be obtained as:","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"pre_img = pre_image(m_dist, mt_chain);\nkde_img = get_kde_image(pre_img..., false, xscale = :identity, yscale = :identity, yflip = true)","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"We can also obtain the mean and 1 std deviation bounds as:","category":"page"},{"location":"tutorials/fixed_discretization.html","page":"MCMC with fixed discretization","title":"MCMC with fixed discretization","text":"mean_std_plt_lin = get_mean_std_image(pre_img..., yscale = :identity)","category":"page"},{"location":"tutorials/rto.html#RTO-TKO","page":"RTO-TKO","title":"RTO-TKO","text":"","category":"section"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"RTO-TKO is a stochastic framework introduced in the MT community by Blatter et al., 2022 ((a)[ https://doi.org/10.1093/gji/ggac241] and (b)[https://doi.org/10.1093/gji/ggac242])","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"Similar to fixed discretization scheme, the grid sizes do not change. RTO-TKO chooses a perturbation in the prior space and optimzes for a response sampled from the response domain.","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"Let's have","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"m = m_1 m_2 m_3   m_N \nh = h_1 h_2 h_3   h_N_1","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"and ","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"d = mathcalF(m)","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"Let C_d be the data covariance matrix and we want to explore uncertainty for the following misfit function:","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"J(m) = mathcalF(m) - d^T C_d mathcalF(m) - d + mu (Lm)^T(Lm)","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"where mu is the regularization weight and L is the derivative matrix. RTO-TKO explores the uncertainty in mu-space instead of fixing it and gives a family of models that fit the data. The algorithm works as:","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"Solving for","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"beginalign*\n J(m) = mathcalF(m) - d^T C_d mathcalF(m) - d + mu (Lm)^T(Lm) \n\n 1) quad textSolve for   m_i+1 \n textSample    tilded sim mathcalN(d C_d) text and  tildem sim mathcalN(0 frac1mu(L^T L))\n\n textSolve \n m_i+1 = argmin_m_i+1 quad mathcalF(m_i+1) - tilded^T C_d mathcalF(m_i+1) - tilded + mu_i L(m_i+1 - tildem)^TL(m_i+1 - tildem) \n\n 2) quad textSolve for   mu_i+1 \n textSample    tilded sim mathcalN(d C_d) \n\n textSolve \n mu_i+1 = argmin_mu_i+1 quad mathcalF(m_i+1) - tilded^T C_d mathcalF(m_i+1) - tilded - log(p(mu_i+1)) \nendalign*","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"note: Note\nUsually, the prior of muis a uniform distribution and we do not have to compute the log pdf term\nImplementing the above from scratch might not be trivial because of L^T L being non-invertible","category":"page"},{"location":"tutorials/rto.html#Copy-Pasteable-code","page":"RTO-TKO","title":"Copy-Pasteable code","text":"","category":"section"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"using MT\nusing Distributions\nusing Turing\nusing LinearAlgebra\n\n\nm_test = MTModel(log10.([100., 10., 1000.]), [1e3, 1e3]);\nf = 10 .^ range(-4, stop = 1, length = 25);\nω = vec(2π .* f);\n\nr_obs = forward(m_test, ω);\n\nerr_phi = asin(0.01) * 180/π .* ones(length(ω));\nerr_appres = 0.02 * r_obs.ρₐ;\nerr_resp = MTResponse(err_appres, err_phi);\n\nr_obs.ρₐ .= r_obs.ρₐ .+ err_appres;\nr_obs.ϕ .= r_obs.ϕ .+ err_phi;\n\nrespD = MTResponseDistribution(normal_dist, normal_dist);\n\nz = 10 .^collect(range(1, stop = 4, length = 100));\nh = diff(z);\n\n# fixed discretization\nmodelD = MTModelDistribution(\n    Product(\n    [Uniform(-1., 5.) for i in eachindex(z)]\n    ),\n    vec(h)\n);\n\nn_samples = 50;\nr_cache = MT.rto_cache(m_rto, [1e-6, 1e2], Occam(), 50, 1000, 1.0, [:ρₐ, :ϕ], false)\n\nrto_chain = stochastic_inverse(r_obs, err_resp, ω, r_cache)\n\nmt_chain = Turing.Chains(\n        (rto_chains.value.data[:,1:length(z),:]), [Symbol(\"ρ[$i]\") for i in 1:length(z)]);\n","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"The obtained mt_chain contains the distributions that can be saved using JLD2.jl.","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"using JLD2\nJLD2.@save \"file_path.jld2\" mt_chain","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"Note: ","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"note: Note\nThe returned chains will be sampled in the distribution specified by modelD. In the presented case, it will have values in -1 5 and we can get the values by 10. ^ value.","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"The list of models can then be obtained from chains using","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"model_list = get_model_list(mt_chains, modelD)","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"We can then easily check the fit of the response curves","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"plt_resps = prepare_plot(r_obs, ω, alpha = 0.);\nresp_models = forward(model_list[1], ω);\n\nfor i in 1:(length(model_list) > 50 ? 50 : length(model_list))\n   forward!(resp_models, model_list[i], ω);\n   prepare_plot!(resp_models, ω, alpha = 0.4); \nend\n\nprepare_plot!(r_obs, ω, d_err = err_resp, markersize = 3, color = :orange);\nplot_response(plt_resps)","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"The posterior distribution can then be obtained as:","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"pre_img = pre_image(m_dist, mt_chain);\nkde_img = get_kde_image(pre_img..., false, xscale = :identity, yscale = :identity, yflip = true)","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"We can also obtain the mean and 1 std deviation bounds as:","category":"page"},{"location":"tutorials/rto.html","page":"RTO-TKO","title":"RTO-TKO","text":"mean_std_plt_lin = get_mean_std_image(pre_img..., yscale = :identity)","category":"page"},{"location":"vizualization.html#Vizualization","page":"Vizualization","title":"Vizualization","text":"","category":"section"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"We make use of Makie.jl to generate images. This allows us to be more flexible with and also generate more fancy figures.","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Here, we want to give a slightly detailed outlook on generating figures. Makie.jl provides multiple backends to generate graphics. We use CairoMakie because it uses CPUs and is compatible with most machines. There is also GLMakie which makes use of GPUs, and the same functions should work with any backend.","category":"page"},{"location":"vizualization.html#Using-Makie","page":"Vizualization","title":"Using Makie","text":"","category":"section"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Makie.jl works around three objects : scene, figure and axis. Of these three, scene is mostly useful for 3D rendering, which, while is a nice feature, is not really useful for us. We, therefore, make use of the latter two.","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"While a more interested reader is encouraged to explore the Makie.jl documentation, here we suffice by saying that a figure is the whole figure, containing multiple axis objects. Each axis can contain a plot, colorbar, legend, etc. Therefore, we advised that while creating legends, use another axis. This allows more control.","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"For the purpose of this tutorial, know that when you call a plotting function, it returns a figure and all the axis in the figure. You must have guessed by now, but we want to make it slightly more explicit that most of the plotting happens on axis while figure is just a container around it to control the aspects (pun intended) of the figure. Therefore, when overlaying multiple plots on the same graph, we only need axis and not necessarily figure. All the mutating functions, therefore, ask for axis. ","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"If you want to make an empty figure, just call:","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"using CairoMakie\nf = Figure(size = (200, 200))\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"We now have the container. Time to add an axis:","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"ax = Axis(f[1,1])\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Let's add another","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"ax1 = Axis(f[2,1])\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"and another...","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"ax2 = Axis(f[2,2])\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Notice the arrangement of axes according to the indices passed for f in Axis. This allows us to create more fanciful layouts:","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"f = Figure(size = (200, 200))\nax1 = Axis(f[1:2, 1]) \nax2 = Axis(f[1:2, 2]) \nax3 = Axis(f[3, 1]) \nax4 = Axis(f[3, 2]) \nax5 = Axis(f[1:3, 3])\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"The usage will become more apparent with the following example:","category":"page"},{"location":"vizualization.html#Plotting-models","page":"Vizualization","title":"Plotting models","text":"","category":"section"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Let's say you have a model defined as :","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"using MT\n\nρ= log10.([500., 100., 400., 1000.]);\nh= [100., 1000., 10000.];\nm= MTModel(ρ, h)","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Now, we plot the model with :","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"f, ax = plot_model(m)\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"See how the plot_model function returns a figure and an axis. If we want to overlay another model on the same plot, we make use of plot_model!","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"ρ= log10.([50., 100., 1000., 200.]);\nh= [1000., 1000., 10000.];\nm2= MTModel(ρ, h)\n\nplot_model!(ax, m)","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"We only needed to pass ax to plot on the same axis. This might also seem a bit intuitive as well. At this point, we want to encourage creating empty figure beforehand and then always using plot_model!(...). This gives us more control on how the axes are arranged among other stuff. Here's an example to make things clear.","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"\nρ= log10.([500., 100., 400., 1000.]);\nh= [100., 1000., 10000.];\nm= MTModel(ρ, h)\n\nf = Figure() # creating empty figure\nax = Axis(f[1,1])\n\nρ= log10.([50., 100., 1000., 200.]);\nh= [1000., 1000., 10000.];\nm2= MTModel(ρ, h)\n\nplot_model!(ax, m)\nplot_model!(ax, m2)\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Notice how the above plots did not have legends. Remember that legends were another axis. ","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"ρ= log10.([500., 100., 400., 1000.]);\nh= [100., 1000., 10000.];\nm= MTModel(ρ, h)\n\nf = Figure() # creating empty figure\nax = Axis(f[1,1])\n\nρ= log10.([50., 100., 1000., 200.]);\nh= [1000., 1000., 10000.];\nm2= MTModel(ρ, h)\n\nplot_model!(ax, m, label = \"m1\")\nplot_model!(ax, m2, label = \"m2\")\n\nLegend(f[1,2], ax)\nf","category":"page"},{"location":"vizualization.html#Plotting-responses","page":"Vizualization","title":"Plotting responses","text":"","category":"section"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Plotting responses is pretty similar. ","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"T= 10 .^(range(-1,5,length= 57));\nω= 2π./T;\n\nresp= forward(m, ω);\nf, axs= plot_response(ω, resp, label = \"1st\", plt_type = :scatter)\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"axs now has two axes because MTResponse has two responses, apparent resistivity and phase. Overlaying is also nothing different. Pass the axis in the mutating form of function.","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"resp2= forward(m2, ω);\nplot_response!(axs, ω, resp, label = \"2nd\", plt_type = :scatter)\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"We again want to emphasize that creating an empty figure first followed by the usage of mutating functions is encouraged and gives a lot more control. We again demonstrate the same by including legend in the plots.","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"f = Figure()\nax1 = Axis(f[1,1])\nax2 = Axis(f[2,1])\n\naxs = [ax1, ax2]\nplot_response!(axs, ω, resp, label = \"1st\", plt_type = :scatter)\nplot_response!(axs, ω, resp2, label = \"2nd\", plt_type = :scatter)\n\nLegend(f[1:2,2], ax2)\nf","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"Creating a figure beforehand and following the recommended guidlines also allows us to plot figures as we like:","category":"page"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"f = Figure()\nax1 = Axis(f[1:3,1], xminorticksvisible = true, backgroundcolor = (:gray, 0.1))\nax2 = Axis(f[1:3,2], xminorticksvisible = true,  backgroundcolor = (:magenta, 0.1))\n\naxs = [ax1, ax2]\nplot_response!(axs, ω, resp, label = \"1st\", plt_type = :scatter)\nplot_response!(axs, ω, resp2, label = \"2nd\", plt_type = :scatter)\n\nLegend(f[4,1:2], ax2, orientation = :horizontal)\nf","category":"page"},{"location":"vizualization.html#Concluding-remarks","page":"Vizualization","title":"Concluding remarks","text":"","category":"section"},{"location":"vizualization.html","page":"Vizualization","title":"Vizualization","text":"This tutorial is to give you a walkthrough of how Makie works in our context. Most other plotting functions in the package follow the same style. There are certain other keyword arguments specific to each of these functions, eg. half_space_thickness in plot_model!() and plt_type in plot_response!(). Information on these arguments specific to such functions are available in their docstrings.","category":"page"},{"location":"working_with_mtpy.html#Working-with-mtpy","page":"mtpy tutorial","title":"Working with mtpy","text":"","category":"section"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"MT.jl allows users to take advantage of the mtpy through the python calls offered by PyCall.jl. Installing Pycall.jl and making mtpy work can be slightly tricky. As mtpy gets updated, users would want to use the latest updated versions. To make things easier, we do not install mtpy via conda or python, and not get involved in the messy virtual environments, we simply clone mtpy from the github repo.","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"Add compat dependency for PyCall","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"We provide a walktthrough to help get things started and get to the point to use this package. We begin by importing different packages.","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"using LinearAlgebra\nusing MT\nusing PyCall\nusing Statistics\nusing Plots\nusing JLD2","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"To import mtpy, we need to provide its path, relative paths work as well. In our case, the repo is cloned at ../../mtpy_v2/mtpy.","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"We now have access to all the functions provided by mtpy. You can now use the package any way you want. The following lines of code demonstrate how we take a .h5 file, which is also created by mtpy (check relevant tutorials).","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"np = pyimport(\"numpy\")\n\nfilename = abspath(joinpath(dirname(@__FILE__),\"../../../../mtpy_v2/mtpy\"))\n(path, name) = dirname(filename), basename(filename)\n\n@pyimport imp\n(file, filename, data) = imp.find_module(name, [path])\nmtpy = imp.load_module(name, file, filename, data)","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"mc = mtpy.MTCollection()\n\nmc.open_collection(\"../../../data_for_mtpy_demo/tf_collection2.h5\")\n\ndf= mc.master_dataframe\nlats= 1 .* mc.master_dataframe[\"latitude\"]\nlons= 1 .* mc.master_dataframe[\"longitude\"]\n\nidx_sort= 1 .+ np.argsort(lats);\nn_stations= length(idx_sort);\nst_keys0= np.array(mc.master_dataframe[\"survey\"])\nst_keys= st_keys0[idx_sort] # station keys, we call st 0 as unknown_survey, st 1 as unknown_survey_002","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"At the time of writing this, I was not able to completely figure out how to export apparent resistivity and phase data along with the corresponding error bars. In the next section, we calculate these parameters using julia and demonstrate compatibility with mtpy functions and objects.","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"tf_arr= [];\nz_arr= [];\nzerr_arr= [];\nf_arr= [];\nfor i in 1:n_stations\n    tfi= mc.get_tf(tf_id= \"P\", survey= st_keys[i]);\n    # tf_arr.append(tfi);\n    push!(tf_arr, tfi);\n    push!(z_arr, np.array(tfi.impedance));\n    push!(zerr_arr, np.array(tfi.impedance_error));\n    # zerr_arr.append(np.array(tfi.impedance_error));\n    push!(f_arr, np.array(tfi.frequency));\nend\n\nρₐ_all= [abs.(z_arr[i]).^2 ./(2* π .* f_arr[i]) for i in eachindex(z_arr)]\nϕ_all= [angle.(z_arr[i]) .*180/π for i in eachindex(z_arr)]\n\nfor i in eachindex(ϕ_all)\n    ϕ_all[i][ϕ_all[i] .<0.] .= ϕ_all[i][ϕ_all[i] .<0.] .+ 180.\nend\n\nρₐerr= [2 .* zerr_arr[i] .* abs.(z_arr[i])./(2* π .* f_arr[i]) for i in 1:n_stations]\nϕerr= [];\nfor i in 1:n_stations\n    r= zerr_arr[i]./abs2.(z_arr[i]);\n    err_r= zero(r);\n    err_r[r.>1].= NaN;\n    err_r[r.<=1].= 180/π .*asin.(zerr_arr[i][r.<=1]./abs2.(z_arr[i][r.<=1]));\n    push!(ϕerr, err_r)\nend\n\nplts= [];\nusing Plots\nplt3 = plot();\nfor i in 1:n_stations\n    scatter!(plt3, [lons[i]], [lats[i]], markersize = 2, label = false)\nend\n\nanim = @animate for i in 1:n_stations\n    plt1= scatter(1 ./f_arr[i], ρₐ_all[i][:,1,2], yerr= (ρₐerr[i][:,1,2]), scale=:log10, label= \"XY\", markersize= 3)\n    scatter!(plt1, 1 ./f_arr[i], ρₐ_all[i][:,2,1], yerr= (ρₐerr[i][:,2,1]), scale=:log10, label= \"YX\", markersize= 3)\n    plot!(plt1, ylim= (1, 1e4), size= (1200, 500), ylabel = \"ρₐ(Ωm)\", xlabel = \"T(s)\");\n\n    plt2= scatter(1 ./f_arr[i], ϕ_all[i][:,1,2], yerr= (ϕerr[i][:,1,2]), xscale=:log10, label= \"XY\", markersize= 3)\n    scatter!(plt2, 1 ./f_arr[i], ϕ_all[i][:,2,1], yerr= (ϕerr[i][:,2,1]), xscale=:log10, label= \"YX\", markersize= 3)\n    plot!(plt2, ylim= (0, 90), size= (1200, 500), ylabel = \"ϕ(°)\", xlabel = \"T(s)\");\n\n    plt= plot(plt1, plt2, layout= (1,2), margin= 5Plots.mm, legend=:outertopright, size = (800, 350), title = \"$i\");\nend\n\ngif(anim, fps= 0.5)","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"Similar plots can also be made with MT.jl. We just need to create the corresponding MTResponses and plot them.","category":"page"},{"location":"working_with_mtpy.html","page":"mtpy tutorial","title":"mtpy tutorial","text":"anim = @animate for i in 1:n_stations\n    xy_resp = MTResponse(ρₐ_all[i][:,1,2], ϕ_all[i][:,1,2])\n    xy_err_resp = MTResponse(ρₐerr[i][:,1,2], ϕerr[i][:,1,2])\n\n    yx_resp = MTResponse(ρₐ_all[i][:,2,1], ϕ_all[i][:,2,1])\n    yx_err_resp = MTResponse(ρₐerr[i][:,2,1], ϕerr[i][:,2,1])\n\n    plt = prepare_plot(xy_resp, 2π.*f_arr[i], xy_err_resp, label = \"XY\", markershape = :circle, maerkersize = 3)\n    prepare_plot!(plt, yx_resp, 2π.*f_arr[i], yx_err_resp, label = \"YX\", markershape = :circle, markersize = 3)\n    plot!(plt[1], ylim = (1, 1e5))\n    plot!(plt[2], ylim = (0, 90))\n\n    plot_response(plt, layout= (1,2), margin= 5Plots.mm, legend=:outertopright, size = (800, 350), title = \"$i\")\nend\n\ngif(anim, fps= 0.5)","category":"page"},{"location":"index.html#MT.jl","page":"Home","title":"MT.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"MT.jl is supposed to be a high performance code for doing forward and inverse modeling in geophysics using julia. We hope to write the code structure such that any other geophysical survey can also be used and we can tend towards a joint forward and inverse modeling library.","category":"page"},{"location":"index.html#Forward-modeling","page":"Home","title":"Forward modeling","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"While forward modeling typically requires solving a PDE obtained using the quasi-static approximation, in 1D, we are fortunate to have the solution for surface impedance in a more analytical form. Currently, this is what is supported.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Supported methods:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"1D Magnetotellurics (MT)","category":"page"},{"location":"index.html#Inverse-modeling","page":"Home","title":"Inverse modeling","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"No surprises here that we are almost always trying to solve for an under-determined system.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Deterministic schemes supported:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Occam\nNonlinear schemes using NonlinearSolve.jl \nNonlinear schemes using Optimization.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Probabilistic schemes supported:'","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"MCMC with fixed grids\nMCMC with flexible grids\nRTO-TKO","category":"page"},{"location":"index.html#Rock-physics","page":"Home","title":"Rock physics","text":"","category":"section"}]
}
